#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

VERSION=3.2
DATE=Jan/2015
JAROMAILEXEC=$0
typeset -a OLDARGS
for arg in ${argv}; do OLDARGS+=($arg); done

##########################
# declare global variables

QUIET=0
DEBUG=0
DRYRUN=0
CALLMUTT=1

# use gnome-keyring for passwords on GNU systems
GNOMTEKEY=0

# default permission on files
umask 066

# global variables for binaries called
typeset -h rm mkdir mutt

# load zsh regex module
zmodload zsh/regex
zmodload zsh/mapfile
zmodload zsh/system
zmodload -F zsh/stat b:zstat
zmodload zsh/sched
# date stamp
datestamp=`date '+%d%b%y'`
##########################

# SQL command
SQL=sqlite3


PARAM=()
typeset -A global_opts
typeset -A opts

typeset -h global_quit
global_quit=0

# global variable for account selection
typeset -h account account_type
# account=default
typeset -h list
list=whitelist

# global variables for accounts
typeset -h name login imap imap_port smtp smtp_port protocol password auth accountopt
typeset -ah folders exclude
typeset -h host port type

# global variables for addressbook
typeset -h hostname addressbook addressbook_tmp

# global variables for email parsers
typeset -A e_addr
typeset -h e_parsed

# global array for maildirs (filled by list_maildirs)
typeset -al maildirs


# global variable for mutt binary
typeset -h mutt pgpewrap dotlock

# global variable for exit code
typeset -h exitcode
# exitcode=0

# global variable for infos on imap folder
# format: name;num_of_messages;size_in_bytes
# last entry is grand_total_in_bytes ${imap_info[${#imap_info}]}
typeset -alU imap_info

# global variable for mutt options
typeset -h muttflags

autoload colors; colors

# temporary directory
typeset TMPPREFIX=${TMPPREFIX:-/tmp}
typeset -H JAROTMP # Filename of secure temp just created (see _tmp_create())
typeset -aH JAROTMPFILES      # Keep track of temporary files

# Provide a random filename in shared memory
_tmp_create() {
    [[ -d "$TMPPREFIX" ]] || {
        # we create the tempdir with the sticky bit on
        mkdir -m 1777 "$TMPPREFIX"
        [[ $? == 0 ]] || _failure "Fatal error creating the temporary directory: ::1 temp dir::" "$TMPPREFIX"
    }
    
    # We're going to add one more $RANDOM for each time someone complain
    # about this being too weak of a random.
    tfile="${TMPPREFIX}/$RANDOM$RANDOM$RANDOM$RANDOM"   # Temporary file
    umask 066
    [[ $? == 0 ]] || {
        error "Fatal error setting the permission umask for temporary files"
        return 1
    }
    
    [[ -r "$tfile" ]] && {
        error "Someone is messing up with us trying to hijack temporary files."
        return 1
    }
    
    touch "$tfile"
    [[ $? == 0 ]] || {
        error "Fatal error creating a temporary file: ::1 temp file::" "$tfile"
        return 1
    }
    
    [[ $? == 0 ]] || {
        error "Fatal error setting ownership on temporary file: ::1 temp file::" "$tfile"
        return 1
    }
    
    func "Created tempfile: $tfile"
    JAROTMP="$tfile"
    JAROTMPFILES+=("$tfile")
    
    return 0
}

# standard output message routines
# it's always useful to wrap them, in case we change behaviour later
notice() { if [[ $QUIET == 0 ]]; then print "$fg_bold[green][*]$fg_no_bold[default] $1" >&2; fi }
error()  { if [[ $QUIET == 0 ]]; then print "$fg[red][!]$fg[default] $1" >&2; fi }
func()   { if [[ $DEBUG == 1 ]]; then print "$fg[blue][D]$fg[default] $1" >&2; fi }
act()    {
    if [[ $QUIET == 0 ]]; then
    if [ "$1" = "-n" ]; then
        print -n "$fg_bold[white] . $fg_no_bold[default] $2" >&2;
    else
        print "$fg_bold[white] . $fg_no_bold[default] $1" >&2;
    fi
    fi
}

# honor quiet and debug flags as early as possible
if [[ ${@} == *-q* ]]; then QUIET=1; fi
if [[ ${@} == *-D* ]]; then DEBUG=1; fi


# what operating system are we in? use os_detect()
# simplifying modes of operation: GNU or MAC
case $(uname -o) in
    GNU/Linux) OS=GNU
    notice "Jaro Mail v$VERSION running on GNU/Linux"	;;

    Darwin) OS=MAC
    notice "Jaro Mail v$VERSION running on Mac/OSX"	;;

    Cygwin) OS=WIN
	    notice "Jaro Mail v$VERSION runing on MS/Win" ;;
	    
    *) OS=GNU # default
    error "Running on an unknown operating system, assuming GNU" ;;
esac

# check if we are inside the directory
if [ -r jaro/bin/jaro ]; then
    MAILDIRS=`pwd`

# check if we are on OSX
elif [ -r /Applications/JaroMail.app ]; then
    MAILDIRS="$HOME/Library/Application Support/JaroMail"

# else use GNU/Linux default
else
    MAILDIRS=$HOME/Mail
fi

# end override
{ test "$JAROMAILDIR" = "" } || { MAILDIRS="$JAROMAILDIR" }

# default working dir


# check if we are testing from source
if [ -r ../src/jaro ]; then
    WORKDIR="../src"
# check if we are on OSX
elif [ -r /Applications/JaroMail.app/Contents/Resources/jaro ]; then
    WORKDIR="/Applications/JaroMail.app/Contents/Resources/jaro"
else # use GNU/Linux default
    WORKDIR="/usr/local/share/jaromail"
fi

# env override
[[ "$JAROWORKDIR" = "" ]] || { WORKDIR="${JAROWORKDIR}" }

# default addressbook
ADDRESSBOOK="$MAILDIRS/whitelist.abook"

# which command to use when creating dirs
mkdir="`command -v mkdir` -m 700 -p"


act "Maildirs in $MAILDIRS"
act "System in $WORKDIR"
${=mkdir} "$MAILDIRS"
#${=mkdir} $WORKDIR

# make sure the permissions are private
#chmod 700 $WORKDIR
chmod 700 "$MAILDIRS"

PATH=$WORKDIR/bin:/bin:/sbin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin::/opt/local/bin

# load our ZLibs
if [ -d $WORKDIR/zlibs ]; then
    # if testing from source load uncompiled libs
    if [ "$WORKDIR" = "../src" ]; then
    for z in `find $WORKDIR/zlibs -type f`; do
        func "Loading zlib: ${z}"
        source ${z}
    done
    else
    for z in `find $WORKDIR/zlibs -type f | grep -v '.zwc$'`; do
        func "Loading zlib: ${z}"
        source ${z}
    done
    fi

    act "full set of auxiliary functions loaded"
elif [[ $1 = source ]]; then

    act "limited set of auxiliary functions loaded"

else
    error "No ZLibs found in $WORKDIR/zlibs"
    error "This installation of Jaro Mail is broken."
    exit 1
fi

ACCOUNTS="$MAILDIRS/Accounts"
KEYRING="$MAILDIRS/Keyring"


# Cleanup anything sensitive before exiting.
endgame() {
    func "endgame() $1"
    [[ "$1" = "NOERRORS" ]] || {
        error "$1 signal sent to processes, waiting to quit..."
        global_quit=1
        sleep 2
    }
    # Clear temporary files
    for f in $JAROTMPFILES; do
        func "endgame() cleaning tempfile $f"
        rm -f "$f"
    done
    JAROTMPFILES=()

    func "endgame() exit code: $exitcode"
    return $exitcode
}
# Trap functions for the endgame event
TRAPINT()  { endgame INT;   return $? }
# TRAPEXIT() { endgame EXIT;  return $? }
TRAPHUP()  { endgame HUP;   return $? }
TRAPQUIT() { endgame QUIT;  return $? }
TRAPABRT() { endgame ABORT; return $? }
TRAPKILL() { endgame KILL;  return $? }
# TRAPPIPE() { endgame PIPE;  return $? }
TRAPTERM() { endgame TERM;  return $? }
TRAPSTOP() { endgame STOP;  return $? }
# TRAPZERR() { func "function returns non-zero." }

case $OS in
    GNU)        
        # backward compatibility tests for old paths in JaroMail <1.3
        { test -d $WORKDIR/Accounts } && { test ! -d $ACCOUNTS } && {
            act "Updating accounts location: $ACCOUNTS"
            cp -ra $WORKDIR/Accounts $ACCOUNTS
        }
        
        { test -r "$WORKDIR/keyring" } && { test ! -r "$KEYRING" } && {
            act "Updating keyring location: $KEYRING"
            cp $WORKDIR/keyring "$KEYRING"
        }        
    ;;
    MAC)
    ;;
esac

hostname=$(hostname) # gather the current hostname


[[ "$1" = "source" ]] || { # skip checks if just sourcing

# make sure we have a directory for account configurations
{ test -d "$ACCOUNTS" } || { ${=mkdir} "$ACCOUNTS" }

# make sure we have a local keyring in case system-wide not found
{ test -r "$KEYRING" } || { create_keyring "$KEYRING" }

# make sure we have an addressbook
[[ -r "$ADDRESSBOOK" ]] || { create_addressbook "$ADDRESSBOOK" }

${=mkdir} "$MAILDIRS/logs"
# ${=mkdir} "$MAILDIRS/certs"

MUTTDIR="$MAILDIRS/.mutt"
{ test -d "$MUTTDIR" } || { ${=mkdir} "$MUTTDIR" }

# make sure we have Filters.txt Applications.txt Mutt.txt
{ test -r "$MAILDIRS/Filters.txt" } || {
    cp "$WORKDIR/Filters.txt" "$MAILDIRS/Filters.txt"
    notice "Default filters created" }

{ test -r "$MAILDIRS/Applications.txt" } || {
    cp "$WORKDIR/Applications.txt" "$MAILDIRS/Applications.txt"
    notice "Default helper applications settings created" }

{ test -r "$MAILDIRS/Mutt.txt" } || {
    cp "$WORKDIR/Mutt.txt" "$MAILDIRS/Mutt.txt"
    notice "Default Mutt configuration template created" }

} # if not sourcing

_mutt() {
    for i; do _fa+=" $i "; done
    func "exec: mutt -F $MUTTDIR/rc ${=muttflags} ${_fa}"
    [[ "$subcommand" = "peek" ]] || rm -f $MUTTDIR/muttpass
    touch $MUTTDIR/muttpass
    mutt -F $MUTTDIR/rc ${=muttflags} ${=_fa}
    return $?
}

# binary programs recognition
check_bin() {

    # required programs
    for req in pinentry fetchmail gpg mutt msmtp; do
    command -v $req >/dev/null
    { test $? != 0 } && {
        error "Cannot find $req. Please install it."
        exit 1
    }
    done

    # make sure a gnupg dir exists
    { test -r $HOME/.gnupg/pubring.gpg } || {
        ${=mkdir} $HOME/.gnupg
        touch $HOME/.gnupg/pubring.gpg
        touch $HOME/.gnupg/secring.gpg
    }

    # which find command to use
    case $OS in
        GNU) find="find -O3" ;;
        MAC) find="gfind -O3" ;;
        *) find="find"
    esac

    # which wipe command to use
    if command -v wipe > /dev/null; then
        rm="wipe -f -s -q -R /dev/urandom"
    elif command -v srm > /dev/null; then
        rm="srm -m"
    else
        rm="rm -f"
    fi
    func "Rm binary: $rm"

    # which mutt binary to use
    if command -v mutt > /dev/null; then
        # system-wide
        # TODO: check if this is also the location on Fedora
        pgpewrap="${WORKDIR}/bin/gpgewrap"
        dotlock="${WORKDIR}/bin/dotlock"
    elif command -v mutt-jaro > /dev/null; then
        # in-house compiled
        mutt=mutt-jaro
        pgpewrap=pgpewrap
        dotlock=dotlock
    else
        error "Cannot find Mutt. Please install it."
        exit 1
    fi
    func "Mutt binary: `command -v mutt`"
    func "Notmuch binary: `command -v notmuch`"
    func "Alot binary: `command -v alot`"

    ps ax | grep '[g]nome-keyring-daemon' > /dev/null
    [[ $? = 0 ]] && {
        act "using gnome-keyring to store secrets"
        GNOMEKEY=1
    }
    
    return 0
}


option_is_set() {
    #First argument, the option (something like "-s")
    #Second (optional) argument: if it's "out", command will print it out 'set'/'unset'
    #                       This is useful for if conditions
    #Return 0 if is set, 1 otherwise
    [[ -n ${(k)opts[$1]} ]];
    r=$?
    if [[ $2 == out ]]; then
    if [[ $r == 0 ]]; then
        echo 'set'
    else
        echo 'unset'
    fi
    fi
    return $r;
}
option_value() {
    #First argument, the option (something like "-s")
    <<< ${opts[$1]}
}


usage() {
    cat <<EOF | more
Jaro Mail $VERSION - your humble and faithful electronic postman

Synopsis: jaro [options] [command] [command-options]

Main commands:

 fetch  download unread emails from [account]
 send   send all mails queued in the outbox
 peek   look into the [account] mailbox without downloading
 index  build or update the search index for all maildirs
 search search maildirs or addressbook for expressions

Options:

 -a     use a particular [account] instead of default
 -l     set [abook] in use, 'whitelist' is default
 -n     dry run, show operations without executing them
 -q     run quietly without printing information
 -D     print debugging information at runtime
 -v     version information for this tool
 -h     print this help

== Addressbook commands (use -l to indicate which addressbook)
a pipe | in front indicate they take an email body from stdin

 abook    edit the [abook] using the console editor

 extract  list addresses of all recipients or senders found in:
          maildir, search expr, vcard, gnupg keyring or pubkey

|import   read address list from stdin into addressbook or group
          (the output of extract commands can be piped to import)


== Operational commands (use -a to indicate [account])

 fetch    downloads emails locally from [account]

 send     send all outbox/ queue via the [account]'s smtp

 peek     interactive connection to an [account]'s imap folder
          (takes folder names as argument, default is INBOX)

 passwd   set [account]'s passwords in the OS native keyring

|queue    read a mail from stdin and queue it in outbox/ for sending

|smtp     read a mail from stdin and send it via [accounts]'s smtp


== Storage commands 

 open     open a maildir folder (can use -R for read-only)

 backup   move search results from a maildir to another one
          (string or date range matches, can use -n for dry-run)

 merge    merge a source maildir into destination, then delete source

 update   updates all filter engine according to Filters.txt
          (also generates Sieve format rules ready for server use)

 filter   process a maildir distributing emails according to Filters.txt
          (if none specified, processes incoming/ - called by fetch)

For a complete introductory documentation, see the User Manual (PDF)
Website on <http://dyne.org/software/jaro-mail>
Report bugs to <https://github.com/dyne/JaroMail/issues>
EOF
}

typeset -A subcommands_opts

main() {
    ### Options configuration
    #Hi, dear developer! Are you trying to add a new subcommand, or to add some options?
    #Well, keep in mind that:
    # 1. An option CAN'T have differente meanings/behaviour in different subcommands.
    #    For example, "-s" means "size" and accept an argument. If you are tempted to add
    #    an option "-s" (that means, for example "silent", and doesn't accept an argument)
#              DON'T DO IT!
        #     There are two reasons for that:
        #       I. usability; user expect that "-s" is "size
    #       II. Option parsing WILL EXPLODE if you do this kind of bad things
    #               (it will say "option defined more than once, and he's right)
    main_opts=(a: -account=a l: -list=l q -quiet=q D -debug=D h -help=h v -version=v n -dry-run=n f -force=f)
    subcommands_opts[__default]="R -readonly=R"
    subcommands_opts[compose]=""
    subcommands_opts[queue]=""
    subcommands_opts[fetch]=""
    subcommands_opts[send]=""
    subcommands_opts[peek]="R -readonly=R"
    subcommands_opts[open]="R -readonly=R"

    subcommands_opts[help]=""

    subcommands_opts[update]=""

    subcommands_opts[stat]=""

    subcommands_opts[index]=""
    subcommands_opts[search]=""
    subcommands_opts[notmuch]=""

    subcommands_opts[learn]=""
    subcommands_opts[forget]=""
    subcommands_opts[list]=""
    subcommands_opts[complete]=""
    subcommands_opts[isknown]=""

    subcommands_opts[import]=""
    subcommands_opts[export]=""
    subcommands_opts[vcard]=""
    subcommands_opts[abook]=""

    subcommands_opts[vim]=""
    subcommands_opts[edit]=""
    subcommands_opts[preview]=""

    subcommands_opts[later]=""
    subcommands_opts[remember]=""

    subcommands_opts[backup]=""
    subcommands_opts[rmdupes]=""
    subcommands_opts[merge]=""
    subcommands_opts[filter]=""
    subcommands_opts[deliver]=""

    subcommands_opts[passwd]=""
    subcommands_opts[cert]=""

    subcommands_opts[ramdisk]=""
    subcommands_opts[source]=""

    subcommands_opts[isonline]=""

    subcommands_opts[init]=""

    subcommands_opts[publish]=""

    subcommands_opts[imap]=""

    subcommands_opts[extract]=""

    subcommands_opts[smtp]=""
    
    subcommands_opts[crypt]=""
    subcommands_opts[cryptsign]=""

    subcommands_opts[isml]=""
    subcommands_opts[ismd]=""

    ### Detect subcommand
    local -aU every_opts #every_opts behave like a set; that is, an array with unique elements
    for optspec in $subcommands_opts$main_opts; do
        for opt in ${=optspec}; do
            every_opts+=${opt}
        done
    done
    local -a oldstar
    oldstar=($argv)
    zparseopts -M -E -D -Adiscardme ${every_opts}
    unset discardme
    subcommand=$1
    if [[ -z $subcommand ]]; then
        subcommand="__default"
    fi
    
    if [[ -z ${(k)subcommands_opts[$subcommand]} ]]; then
        # unknown command, pass it to autostart
        func "unknown command, autostart: $@"
        autostart ${=@}
        exitcode=$?
        [[ $exitcode = 0 ]] || {
            error "command \"$subcommand\" not recognized"
            act "try -h for help"
        }
        return $exitcode
    fi
    
    argv=(${oldstar})
    unset oldstar
    
    ### Parsing global + command-specific options
    # zsh magic: ${=string} will split to multiple arguments when spaces occur
    set -A cmd_opts ${main_opts} ${=subcommands_opts[$subcommand]}
    if [[ -n $cmd_opts ]]; then #if there is no option, we don't need parsing
    zparseopts -M -E -D -Aopts ${cmd_opts}
    if [[ $? != 0 ]]; then
        error "Some error occurred during option processing."
        exitcode=1
        return 1
    fi
    fi
  #build PARAM (array of arguments) and check if there are unrecognized options
    local ok=0
    for arg in $*; do
    if [[ $arg == '--' || $arg == '-' ]]; then
        ok=1
        continue #it shouldnt be appended to PARAM
    elif [[ $arg[1] == '-'  ]]; then
        if [[ $ok == 0 ]]; then
        error "unrecognized option $arg"
        exitcode=1
        return 1
        fi
    fi
    PARAM+=$arg
    done
  #first parameter actually is the subcommand: delete it and shift
    if [[ $subcommand != '__default' ]]; then
    PARAM[1]=()
    shift
    fi
  ### End parsing command-specific options

    if option_is_set -v; then
    cat $JAROMAILEXEC | awk '/^#/ {print $0 } !/^#/ {exit}'
    echo
    fi
    { option_is_set -a } && { account=`option_value -a` }
    { option_is_set -l } && {
        if [[ "`option_value -l`" =~ "black" ]]; then 
            list=blacklist
        elif [[ "`option_value -l`" =~ "white" ]]; then
            list=whitelist
        else
            list=`option_value -l`
        fi
        ADDRESSBOOK="$MAILDIRS"/$list.abook
    }
    { option_is_set -h } && { usage; return 0 }
    { option_is_set -v } && {
        cat $JAROMAILEXEC | awk 'BEGIN { v=1 } !/^#/ { exit }'
        return 0
    }
    { option_is_set -q } && { QUIET=1 }
    { option_is_set -D } && { DEBUG=1; QUIET=0
    func "All debug messages ON" }
    { option_is_set -n } && { DRYRUN=1
    act "Dry run, show operations without executing them." }
    { option_is_set -R } && { muttflags+=" -R " }
    { option_is_set -f } && { FORCE=1 }

    # clean up options from param
    PARAM=(${PARAM// -? /})

    case "$subcommand" in

    compose) compose ${PARAM}
            exitcode=$?
            ;;

    queue)  queue ${PARAM}
            exitcode=$?
            ;;

    fetch)
            account=${account:-default}
            fetch
            filter_maildir incoming
        ;;

    send)   send ${PARAM}
            exitcode=$?
            ;;

    peek)   peek ${PARAM}
            exitcode=$?
            ;;

    later|remember)
            cat | deliver remember
            exitcode=$?
            ;;

    update|init)
        init_inbox
        update_filters
        update_mutt
        update_sieve
	command -v notmuch > /dev/null && {
        nm_setup
        nm new 2>&1 | grep -v '^Note: Ignoring'
}
        ;;

    help) usage ;;

    index) nm_index
           exitcode=$?
           ;;

    search) search ${PARAM} ;;

    notmuch)
            notice "Command: notmuch ${PARAM}"
            nm ${PARAM}
            exitcode=$?
            ;;

#    stat) stats ${PARAM} ;;


    complete) complete ${PARAM}
              exitcode=$?
              ;;

    isknown) sender_isknown ${PARAM}
             exitcode=$?
             ;;

    learn)  learn ${PARAM}
            exitcode=$?
            ;;

    import) import ${PARAM}
            exitcode=$?
            ;;

    vcard)
            export_vcard ${PARAM}
            ;;

    "export")
            case "$PARAM" in
                abook)
                    notice "Exporting old addressbook to new format"
                    list=whitelist; export_abook
                    list=blacklist; export_abook
                    ;;
                vcard) export_vcard ;;
                *) export_vcard ;;
            esac
            ;;

    abook)  edit_abook ${PARAM}
            exitcode=$?
            ;;

    edit|vim)   jarovim ${PARAM}    ;;
    open)       open_folder ${PARAM}  ;;
    preview)    preview_file ${PARAM} ;;

    backup)  backup ${PARAM}
            exitcode=$?
            ;;

    rmdupes) rmdupes ${PARAM} ;;
    merge)   merge ${PARAM}   ;;

    filter)
        update_filters ${PARAM}
        [[ $? = 0 ]] || {
            error "error updating filters, operation aborted."
            break
        }
        filter_maildir ${PARAM}
        exitcode=$?
        ;;

    deliver)
            deliver ${PARAM}
            exitcode=$?
            ;;

    passwd) new_password ;;

    cert)    cert ${PARAM} ;; # was checking is_online

    ramdisk) ramdisk ${PARAM} ;;

    isonline) is_online ${=PARAM}; exitcode=$? ;;

        
    publish)
        md="$1"
        { maildircheck "$md" 2>/dev/null } || { md="${MAILDIRS}/${md}" }
        pubdb_update "$md"
        pubdb_render_maildir "$md"
        exitcode=$? ;;

    'source')   return 0 ;;
    __default)  func "no command provided"
        autostart ${PARAM}
        exitcode=$?
        ;;

    imap)
        imapcmd="$1"
        case $1 in
        getsize)
            read_account $account
            ask_password
            bytes_total=`imap_get_size "$2"`
            exitcode=$?
            notice "Size of account $login on $imap"
            act "$bytes_total bytes"
            mib_total=$(( $bytes_total / 1048576 ))
            act "$mib_total MB (MiB)"
            ;;
        listfolders)
            read_account $account
            ask_password
            folders=(`imap_list_folders`)
            exitcode=$?
            notice "List of folders for $login on $imap"
            for f in $folders; do print "$f"; done
            ;;
        # interactive)
        #     read_account
        #     ask_password
        #     imap_interactive_shell
        #     exitcode=$?
        #     ;;
        *)
            error "imap needs a subcommand: getsize or listfolders"
            ;;
        esac
        ;;

    list|extract)
        extract ${PARAM}
        exitcode=$?
        ;;

    crypt)
        crypt_queue ${PARAM}
        exitcode=$?
        ;;

    smtp)
        smtp_send ${PARAM}
        exitcode=$?
        ;;

    isml)
        ismailinglist
        [[ $? = 0 ]] && \
            notice "Email read from stdin is a mailinglist" 
        exitcode=$?
        ;;

    ismd)
        maildircheck ${PARAM}
        [[ $? = 0 ]] && \
            notice "Directory is a maildir: ${PARAM}"
        exitcode=$?
        ;;

    *) # unknown command, pass it to autostart
        func "unknown command, remote check"
        autostart ${PARAM}
        exitcode=$?
        [[ $exitcode = 0 ]] || {
            error "command \"$subcommand\" not recognized"
            act "try -h for help"
        }
        ;;
    esac

    return $exitcode
}


check_bin
main $@
endgame NOERRORS
return $exitcode
