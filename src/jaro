#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyright (C) 2010-2015 Dyne.org Foundation
#
# JaroMail is designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

VERSION=4.0
DATE=Nov/2015
JAROMAILEXEC=$0

# default permission on files
umask 066

# honor quiet and debug flags as early as possible
if [[ ${@} == *-q* ]]; then QUIET=1; fi
if [[ ${@} == *-D* ]]; then DEBUG=1; fi


# check if we are inside the directory
if [ -r jaro/bin/jaro ]; then
    MAILDIRS=`pwd`
# check if we are on OSX
elif [ -r /Applications/JaroMail.app ]; then
    MAILDIRS="$HOME/Library/Application Support/JaroMail"
# else use GNU/Linux default
else
    MAILDIRS=$HOME/Mail
fi

# end override
MAILDIRS=${JAROMAILDIR:-$MAILDIRS}


# check if we are testing from source
if [[ -r ../src/jaro ]]; then
    WORKDIR="../src"
# check if we are on OSX
elif [[ -r /Applications/JaroMail.app/Contents/Resources/jaro ]]; then
    WORKDIR="/Applications/JaroMail.app/Contents/Resources/jaro"
elif [[ -r /usr/share/jaromail/bin/jaro ]]; then
    # use GNU/Linux default in usr
    WORKDIR="/usr/share/jaromail"
else
    # use GNU/Linux default in local
    WORKDIR="/usr/local/share/jaromail"
fi

# env override
WORKDIR=${JAROWORKDIR:-$WORKDIR}

# load our zuper extension
zkv=1
helpers=1
source $WORKDIR/zlibs/zuper


# what operating system are we in? use os_detect()
# simplifying modes of operation: GNU or MAC
case $(uname -o) in
    GNU/Linux) OS=GNU
    notice "Jaro Mail v$VERSION running on GNU/Linux"	;;

    Darwin) OS=MAC
    notice "Jaro Mail v$VERSION running on Mac/OSX"	;;

    Cygwin) OS=WIN
        notice "Jaro Mail v$VERSION runing on MS/Win" ;;

    *) OS=GNU # default
    error "Running on an unknown operating system, assuming GNU" ;;
esac



# global variables
vars+=(DEBUG QUIET DRYRUN CALLMUTT MAILDIRS WORKDIR)
QUIET=${QUIET:-0}
DEBUG=${DEBUG:-0}
DRYRUN=${DRYRUN:-0}
CALLMUTT=${CALLMUTT:-1}

# use gnome-keyring for passwords on GNU systems
vars+=(GNOMEKEY)
GNOMEKEY=${GNOMEKEY:-0}


# global variables for binaries called
vars+=(rm mkdir mutt SQL OS)

# load zsh modules
zmodload zsh/regex
zmodload zsh/mapfile
zmodload zsh/system
zmodload -F zsh/stat b:zstat
zmodload zsh/sched

##########################

# SQL command
SQL=sqlite3


PARAM=()
typeset -A global_opts
typeset -A opts

vars+=(global_quit)
global_quit=0

# global variable for account selection
vars+=(account account_type)
# account=default
vars+=(list)
list=whitelist

# global variables for accounts
vars+=(name login imap imap_port smtp smtp_port protocol password auth accountopt)
arrs+=(folders exclude)
vars+=(host port type)

# global for server fingerprints
vars+=(fingerprint)

# global variables for addressbook
vars+=(hostname addressbook addressbook_tmp)

# global variables for email parsers
typeset -A e_addr
vars+=(e_parsed)

# global array for maildirs (filled by list_maildirs)
arrs+=(maildirs)
vars+=(last_deliver)

# stdin when read becomes globally accessible
vars+=(stdin bytesread)
stdin=""
bytesread=0

# global arrays for search results and mailpaths
# are all arrays of absolute paths
arrs+=(search_results mailpaths)
search_results=()

# global variable for mutt binary
vars+=(mutt pgpewrap dotlock)

# global variable for exit code
vars+=(exitcode)
# exitcode=0

# global variable for infos on imap folder
# format: name;num_of_messages;size_in_bytes
# last entry is grand_total_in_bytes ${imap_info[${#imap_info}]}
typeset -alU imap_info

# global variable for mutt options
vars+=(muttflags)

autoload colors; colors

# default addressbook
ADDRESSBOOK="$MAILDIRS/whitelist.abook"

# which command to use when creating dirs
mkdir="`command -v mkdir` -m 700 -p"


act "Maildirs in $MAILDIRS"
act "System in $WORKDIR"
${=mkdir} "$MAILDIRS"
#${=mkdir} $WORKDIR

# make sure the permissions are private
#chmod 700 $WORKDIR
chmod 700 "$MAILDIRS"

PATH=$WORKDIR/bin:/bin:/sbin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin::/opt/local/bin

# load our ZLibs
if [ -d $WORKDIR/zlibs ]; then
    # if testing from source load uncompiled libs
    if [ "$WORKDIR" = "../src" ]; then
    for z in `find $WORKDIR/zlibs -type f`; do
        func "Loading zlib: ${z}"
        source ${z}
    done
    else
    for z in `find $WORKDIR/zlibs -type f | grep -v '.zwc$'`; do
        func "Loading zlib: ${z}"
        source ${z}
    done
    fi

    act "full set of auxiliary functions loaded"
elif [[ $1 = source ]]; then

    act "limited set of auxiliary functions loaded"

else
    error "No ZLibs found in $WORKDIR/zlibs"
    error "This installation of Jaro Mail is broken."
    exit 1
fi



##########
# complete
source $WORKDIR/zlibs/zuper.init



ACCOUNTS="$MAILDIRS/Accounts"
KEYRING="$MAILDIRS/Keyring"

case $OS in
    GNU)
        # backward compatibility tests for old paths in JaroMail <1.3
        { test -d $WORKDIR/Accounts } && { test ! -d $ACCOUNTS } && {
            act "Updating accounts location: $ACCOUNTS"
            cp -ra $WORKDIR/Accounts $ACCOUNTS
        }

        { test -r "$WORKDIR/keyring" } && { test ! -r "$KEYRING" } && {
            act "Updating keyring location: $KEYRING"
            cp $WORKDIR/keyring "$KEYRING"
        }
    ;;
    MAC)
    ;;
esac

hostname=$(hostname) # gather the current hostname

[[ "$1" = "source" ]] || { # skip checks if just sourcing

    # make sure we have a directory for account configurations
    { test -d "$ACCOUNTS" } || { ${=mkdir} "$ACCOUNTS" }

    # make sure we have a local keyring in case system-wide not found
    { test -r "$KEYRING" } || { create_keyring "$KEYRING" }

    # make sure we have an addressbook
    [[ -r "$ADDRESSBOOK" ]] || { create_addressbook "$ADDRESSBOOK" }

    ${=mkdir} "$MAILDIRS/logs"
    # ${=mkdir} "$MAILDIRS/certs"

    MUTTDIR="$MAILDIRS/.mutt"
    { test -d "$MUTTDIR" } || { ${=mkdir} "$MUTTDIR" }

    # make sure we have Filters.txt Applications.txt Mutt.txt
    { test -r "$MAILDIRS/Filters.txt" } || {
        cp "$WORKDIR/Filters.txt" "$MAILDIRS/Filters.txt"
        notice "Default filters created" }

    { test -r "$MAILDIRS/Applications.txt" } || {
        cp "$WORKDIR/Applications.txt" "$MAILDIRS/Applications.txt"
        notice "Default helper applications settings created" }

    { test -r "$MAILDIRS/Mutt.txt" } || {
        cp "$WORKDIR/Mutt.txt" "$MAILDIRS/Mutt.txt"
        notice "Default Mutt configuration template created" }

} # if not sourcing

_mutt() {

    [[ -r $MAILDIRS/.mutt/rc ]] || {
        error "Jaro Mail is not yet configured."
        error "To configure, edit the files in $MAILDIRS/Accounts"
        error "Then run 'jaro update' at least once."
        return 1
    }

    for i; do _fa+=" $i "; done
    func "exec: mutt -F $MUTTDIR/rc ${=muttflags} ${_fa}"
    [[ "$subcommand" = "peek" ]] || rm -f $MUTTDIR/muttpass
    touch $MUTTDIR/muttpass
    mutt -F $MUTTDIR/rc ${=muttflags} ${=_fa}
    return $?
}

# binary programs recognition
check_bin() {

    # required programs
    for req in pinentry fetchmail gpg mutt msmtp; do
        isfound $req
        { test $? != 0 } && {
            error "Cannot find $req. Please install it."
            exit 1
        }
    done

    # make sure a gnupg dir exists
    { test -r $HOME/.gnupg/pubring.gpg } || {
        ${=mkdir} $HOME/.gnupg
        touch $HOME/.gnupg/pubring.gpg
        touch $HOME/.gnupg/secring.gpg
    }

    # which find command to use
    case $OS in
        GNU) find="find -O3" ;;
        MAC) find="gfind -O3" ;;
        *) find="find"
    esac

    # which wipe command to use
    if  isfound wipe; then
        rm="wipe -f -s -q -R /dev/urandom"
    elif isfound srm; then
        rm="srm -m"
    else
        rm="rm -f"
    fi
    func "Rm binary: $rm"

    # which mutt binary to use
    if isfound mutt; then
        # system-wide
        # TODO: check if this is also the location on Fedora
        pgpewrap="${WORKDIR}/bin/gpgewrap"
        dotlock="${WORKDIR}/bin/dotlock"
    elif isfound mutt-jaro; then
        # in-house compiled
        mutt=mutt-jaro
        pgpewrap=pgpewrap
        dotlock=dotlock
    else
        error "Cannot find Mutt. Please install it."
        exit 1
    fi
    func "Mutt binary: `command -v mutt`"
    func "Notmuch binary: `command -v notmuch`"
    func "Alot binary: `command -v alot`"

    ps ax | grep '[g]nome-keyring-daemon' > /dev/null
    [[ $? = 0 ]] && {
        act "using gnome-keyring to store secrets"
        GNOMEKEY=1
    }

    return 0
}


option_is_set() {
    #First argument, the option (something like "-s")
    #Second (optional) argument: if it's "out", command will print it out 'set'/'unset'
    #                       This is useful for if conditions
    #Return 0 if is set, 1 otherwise
    [[ -n ${(k)opts[$1]} ]];
    r=$?
    if [[ $2 == out ]]; then
    if [[ $r == 0 ]]; then
        echo 'set'
    else
        echo 'unset'
    fi
    fi
    return $r;
}
option_value() {
    #First argument, the option (something like "-s")
    <<< ${opts[$1]}
}


usage() {
    cat <<EOF | more
Jaro Mail $VERSION - your humble and faithful electronic postman

Synopsis: jaro [options] [command] [command-options]

Main commands:

 fetch  download unread emails from [account]
 send   send all mails queued in the outbox
 peek   look into the [account] mailbox without downloading
 index  build or update the search index for all maildirs
 search search maildirs or addressbook for expressions

Options:

 -a     use a particular [account] instead of default
 -l     set [abook] in use, 'whitelist' is default
 -n     dry run, show operations without executing them
 -q     run quietly without printing information
 -D     print debugging information at runtime
 -v     version information for this tool
 -h     print this help

== Addressbook commands (use -l to indicate which addressbook)
a pipe | in front indicate they take an email body from stdin

 abook    edit the [abook] using the console editor

 extract  list addresses of all recipients or senders found in:
          maildir, search expr, vcard, gnupg keyring or pubkey

|import   read address list from stdin into addressbook or group
          (the output of extract commands can be piped to import)


== Operational commands (use -a to indicate [account])

 fetch    downloads emails locally from [account]

 send     send all outbox/ queue via the [account]'s smtp

 peek     interactive connection to an [account]'s imap folder
          (takes folder names as argument, default is INBOX)

 passwd   set [account]'s passwords in the OS native keyring

|queue    read a mail from stdin and queue it in outbox/ for sending

|smtp     read a mail from stdin and send it via [accounts]'s smtp


== Storage commands

 open     open a maildir folder (can use -R for read-only)

 backup   move search results from a maildir to another one
          (string or date range matches, can use -n for dry-run)

 merge    merge a source maildir into destination, then delete source

 update   updates all filter engine according to Filters.txt
          (also generates Sieve format rules ready for server use)

 filter   process a maildir distributing emails according to Filters.txt
          (if none specified, processes incoming/ - called by fetch)

For a complete introductory documentation, see the User Manual (PDF)
Website on <http://dyne.org/software/jaro-mail>
Report bugs to <https://github.com/dyne/JaroMail/issues>
EOF
}

typeset -A subcommands_opts

main() {
    ### Options configuration
    #Hi, dear developer! Are you trying to add a new subcommand, or to add some options?
    #Well, keep in mind that:
    # 1. An option CAN'T have differente meanings/behaviour in different subcommands.
    #    For example, "-s" means "size" and accept an argument. If you are tempted to add
    #    an option "-s" (that means, for example "silent", and doesn't accept an argument)
#              DON'T DO IT!
        #     There are two reasons for that:
        #       I. usability; user expect that "-s" is "size
    #       II. Option parsing WILL EXPLODE if you do this kind of bad things
    #               (it will say "option defined more than once, and he's right)
    main_opts=(a: -account=a l: -list=l q -quiet=q D -debug=D h -help=h v -version=v n -dry-run=n f -force=f)
    subcommands_opts[__default]="R -readonly=R"
    subcommands_opts[compose]=""
    subcommands_opts[queue]=""
    subcommands_opts[fetch]=""
    subcommands_opts[send]=""
    subcommands_opts[peek]="R -readonly=R"
    subcommands_opts[open]="R -readonly=R"

    subcommands_opts[help]=""

    subcommands_opts[update]=""

    subcommands_opts[stat]=""

    subcommands_opts[index]=""
    subcommands_opts[search]=""
    subcommands_opts[alot]=""
    subcommands_opts[notmuch]=""

    subcommands_opts[addr]=""
    subcommands_opts[learn]=""
    subcommands_opts[forget]=""

    subcommands_opts[complete]=""
    subcommands_opts[isknown]=""

    subcommands_opts[list]=""
    subcommands_opts[extract]=""
    subcommands_opts[parse]=""
    subcommands_opts[header]=""
    subcommands_opts[headers]=""

    subcommands_opts[import]=""
    subcommands_opts[export]=""
    subcommands_opts[vcard]=""
    subcommands_opts[abook]=""

    subcommands_opts[vim]=""
    subcommands_opts[edit]=""
    subcommands_opts[preview]=""

    subcommands_opts[replay]=""

    subcommands_opts[remember]=""

    subcommands_opts[backup]=""
    subcommands_opts[rmdupes]=""
    subcommands_opts[merge]=""
    subcommands_opts[filter]=""
    subcommands_opts[deliver]=""

    subcommands_opts[passwd]=""
    subcommands_opts[cert]=""

    subcommands_opts[source]=""

    subcommands_opts[isonline]=""

    subcommands_opts[init]=""

    subcommands_opts[publish]=""

    subcommands_opts[imap]=""

    subcommands_opts[smtp]=""

    subcommands_opts[crypt]=""
    subcommands_opts[cryptsign]=""

    subcommands_opts[isml]=""
    subcommands_opts[ismd]=""

    ### Detect subcommand
    local -aU every_opts #every_opts behave like a set; that is, an array with unique elements
    for optspec in $subcommands_opts$main_opts; do
        for opt in ${=optspec}; do
            every_opts+=${opt}
        done
    done
    local -a oldstar
    oldstar=($argv)
    zparseopts -M -E -D -Adiscardme ${every_opts}
    unset discardme
    subcommand=$1
    if [[ -z $subcommand ]]; then
        subcommand="__default"
    fi

    # if [[ -z ${(k)subcommands_opts[$subcommand]} ]]; then
    #     # unknown command, pass it to autostart
    # fi

    argv=(${oldstar})
    unset oldstar

    ### Parsing global + command-specific options
    # zsh magic: ${=string} will split to multiple arguments when spaces occur
    set -A cmd_opts ${main_opts} ${=subcommands_opts[$subcommand]}
    if [[ -n $cmd_opts ]]; then #if there is no option, we don't need parsing
    zparseopts -M -E -D -Aopts ${cmd_opts}
    if [[ $? != 0 ]]; then
        error "Some error occurred during option processing."
        exitcode=1
        return 1
    fi
    fi
  #build PARAM (array of arguments) and check if there are unrecognized options
    local ok=0
    for arg in $*; do
    if [[ $arg == '--' || $arg == '-' ]]; then
        ok=1
        continue #it shouldnt be appended to PARAM
    elif [[ $arg[1] == '-'  ]]; then
        if [[ $ok == 0 ]]; then
        error "unrecognized option $arg"
        exitcode=1
        return 1
        fi
    fi
    PARAM+=$arg
    done
  #first parameter actually is the subcommand: delete it and shift
    if [[ $subcommand != '__default' ]]; then
    PARAM[1]=()
    shift
    fi
  ### End parsing command-specific options

    if option_is_set -v; then
    cat $JAROMAILEXEC | awk '/^#/ {print $0 } !/^#/ {exit}'
    echo
    fi
    { option_is_set -a } && { account=`option_value -a` }
    { option_is_set -l } && {
        if [[ "`option_value -l`" =~ "black" ]]; then
            list=blacklist
        elif [[ "`option_value -l`" =~ "white" ]]; then
            list=whitelist
        else
            list=`option_value -l`
        fi
        ADDRESSBOOK="$MAILDIRS"/$list.abook
    }
    { option_is_set -h } && { usage; return 0 }
    { option_is_set -v } && {
        cat $JAROMAILEXEC | awk 'BEGIN { v=1 } !/^#/ { exit }'
        return 0
    }
    { option_is_set -q } && { QUIET=1 }
    { option_is_set -D } && { DEBUG=1; QUIET=0
    func "All debug messages ON" }
    { option_is_set -n } && { DRYRUN=1
    act "Dry run, show operations without executing them." }
    { option_is_set -R } && { muttflags+=" -R " }
    { option_is_set -f } && { FORCE=1 }

    # clean up options from param
    PARAM=(${PARAM// -? /})

    case "$subcommand" in

    compose) compose ${PARAM}
            exitcode=$?
            ;;

    queue)  queue ${PARAM}
            exitcode=$?
            ;;

    fetch)
            account=${account:-default}
            fetch ${PARAM} && \
                update_filters && \
                filter_maildir incoming && \
                update_notmuch
        ;;

    send)   send ${PARAM}
            exitcode=$?
            ;;

    peek)   peek ${PARAM}
            exitcode=$?
            ;;

    remember)
        cat | deliver remember
        exitcode=$?
        ;;

    replay)
        replay ${PARAM}
        exitcode=$?
        ;;

    update|init)
        [[ "$PARAM" = "" ]] || {
            for p in $PARAM; do
                [[ "$p" = "." ]] && p=$PWD
                [[ -d $p ]] && MAILDIRS=$p
            done
        }
        init_inbox
        update_filters
        update_mutt
        update_sieve
        update_notmuch
        notice "Initialization completed in $MAILDIRS"
        act "configure accounts in $MAILDIRS/Accounts"
        ;;

    help) usage ;;

    index) nm_index
           exitcode=$?
           ;;

    # notmuch search with file output
    search) search ${PARAM}
            [[ $DRYRUN = 1 ]] || {
                for i in ${search_results=}; do
                    print - "$i"
                done
            } | save_replay $subcommand
            ;;

    alot) alot_search ${PARAM} ;;

    notmuch)
            notice "Command: notmuch ${PARAM}"
            nm ${PARAM} | save_replay $subcommand
            exitcode=$?
            ;;

    addr|list) search_addressbook ${PARAM}
               ;;

    complete) complete ${PARAM}
              exitcode=$?
              ;;

    isknown) sender_isknown ${PARAM}
             exitcode=$?
             ;;

    learn)  learn ${PARAM}
            exitcode=$?
            ;;

    import) import ${PARAM}
            exitcode=$?
            ;;

    "export")
            export_vcard ${PARAM}
            ;;

    abook)  edit_abook ${PARAM}
            exitcode=$?
            ;;

    stat*)  stats ${PARAM} | sort -n
            exitcode=$?
            ;;

    edit|vim)   jarovim ${PARAM}    ;;
    open)       open_folder ${PARAM}  ;;
    preview)    preview_file ${PARAM} ;;

    backup)  backup ${PARAM}
             exitcode=$?
             ;;

    rmdupes) rmdupes ${PARAM} ;;
    merge)   merge ${PARAM}   ;;

    filter)
        update_filters ${PARAM}
        [[ $? = 0 ]] || {
            error "error updating filters, operation aborted."
            break
        }
        filter_maildir ${PARAM} | save_replay $subcommand
        exitcode=$?
        ;;

    deliver)
            deliver ${PARAM}
            exitcode=$?
            ;;

    passwd) new_password ;;

    cert)    cert ${PARAM} ;; # was checking is_online

    isonline) is_online ${=PARAM}; exitcode=$? ;;


    publish)
        md="$1"
        { maildircheck "$md" 2>/dev/null } || { md="${MAILDIRS}/${md}" }
        pubdb_update "$md"
        pubdb_render_maildir "$md"
        exitcode=$? ;;

    'source')   return 0 ;;

    imap)
        imapcmd="$1"
        case $1 in
        getsize)
            read_account $account
            ask_password
            bytes_total=`imap_get_size "$2"`
            exitcode=$?
            notice "Size of account $login on $imap"
            act "$bytes_total bytes"
            mib_total=$(( $bytes_total / 1048576 ))
            act "$mib_total MB (MiB)"
            ;;
        listfolders)
            read_account $account
            ask_password
            folders=(`imap_list_folders`)
            exitcode=$?
            notice "List of folders for $login on $imap"
            for f in $folders; do print - "$f"; done \
                | save_replay $subcommand | column

            ;;
        # interactive)
        #     read_account
        #     ask_password
        #     imap_interactive_shell
        #     exitcode=$?
        #     ;;
        *)
            error "imap needs a subcommand: getsize or listfolders"
            ;;
        esac
        ;;

    # list)
    #     list_abook ${PARAM}
    #     exitcode=$?
    #     ;;

    extract|parse)
        extract_addresses ${PARAM} \
            | save_replay $subcommand
        exitcode=$?
        ;;

    header|headers)
        extract_headers ${PARAM}
        exitcode=$?
        ;;

    smtp)
        smtp_send ${PARAM}
        exitcode=$?
        ;;

    isml)
        ismailinglist
        [[ $? = 0 ]] && \
            notice "Email read from stdin is a mailinglist"
        exitcode=$?
        ;;

    ismd)
        maildircheck ${PARAM}
        [[ $? = 0 ]] && \
            notice "Directory is a maildir: ${PARAM}"
        exitcode=$?
        ;;

    # __default)  func "no command provided"
    #     autostart ${PARAM}
    #     exitcode=$?
    #     ;;
    *) # unknown command, pass it to autostart
        func "no command, autostart"

        # argument passed: determine if an email
        if isemail "$subcommand"; then
            notice "Composing message to: ${@}"
            # its an email, TODO see if we have it in our addressbook
            _mutt ${=@}
            exitcode=0
        # or a directory of file
        elif [[ -r "$subcommand" ]]; then
            # is it a maildir? then open
            maildircheck ${subcommand}
            [[ $? = 0 ]] && {
                _mutt -f ${subcommand}
                exitcode=0
            }
            # is it a regular file? then attach it
            [[ -f "$subcommand" ]] && {
                _mutt -a ${=@}
                exitcode=0
            }
        # or the name of a folder in Jaro Mail
        elif [[ -r "$MAILDIRS/$subcommand" ]]; then
            maildircheck "$MAILDIRS/$subcommand" && {
                notice "Opening folder ${subcommand=}"
                _mutt -f "$MAILDIRS/${subcommand}"
                exitcode=0
            }
        else

            # just open mutt on first unread folder
            _mutt -Z
            exitcode=$?

        fi
        ;;
    esac

    return $exitcode
}


check_bin
main $@
# endgame NOERRORS
# return $exitcode
