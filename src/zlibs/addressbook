#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



###################
# Jaro Brother DB
create_addressbook() {
    ab="$ADDRESSBOOK"
    func "create addressbook: $ab"
    [[ -r "$ab" ]] && {
        error "Addressbook already exists: $ab"
        return 1
    }

    [[ -r "$MAILDIRS"/Addressbook ]] && {
        notice "Updating the old addressbook to a new format"
        _list=$list
        list=blacklist; export_abook
        list=whitelist; export_abook
        list=$_list
        mv "$MAILDIRS"/Addressbook "$MAILDIRS"/Addressbook.old 
    }

    touch "$ab"

    # make sure is private
    chmod 600 "$ab"
    chown $_uid:$_gid "$ab"

    return 0
}

insert_address() {
    _email="${1}"; _name="${2}";
    func "insert address: $_name <$_email>"

    lookup_email "$_email"

    [[ $? = 0 ]] && {
        func "address already present in $list"
        return 1
    }
     
    print "From: $_name <$_email>" | \
        abook --datafile "$ADDRESSBOOK" \
        --add-email-quiet

    return 0
}

remove_address() {
    warning "remove_address() TODO in abook branch"
    return 0
}

search_addressbook() {
    func "search \"$@\" in $list"
    abook --datafile "$ADDRESSBOOK" --mutt-query "$@"
}


lookup_email() {
    func "lookup address $1 in $list"
    abook --datafile "$ADDRESSBOOK" \
        --mutt-query "$1" > /dev/null
    return $?
}

complete() {
    func "complete: $1 (list $list)"

    # completion on configured groups
    { test -r "$MAILDIRS/Groups" } && {
        if [[ "$1" =~ "group/" ]]; then
            func "completion will look into groups"
            needle="${1[(ws:/:)2]}"
            if [ "$needle" = "" ]; then
                act "Listing all mailout groups"
                matches=`${=find} "$MAILDIRS/Groups" -type f`
            else
                act "Searching for \"$needle\" in mailout groups"
                matches=`${=find} "$MAILDIRS/Groups" -type f -name \"*$needle*\"`
            fi

            print "Groups: `print $matches | wc -l` matches"
            print
            for i in ${(f)matches}; do
                gr=`basename $i`
                print "$gr@jaromail.group\t`wc -l < $i` recipients"
            done
            return 0
        fi
    }

    act "Searching for \"$1\" in addressbook $list"
    abook --datafile "$ADDRESSBOOK" --mutt-query "$1"
    return $?
}

sender_isknown() {
    # extract only headers from stdin
    head="`awk '
{ print $0 }
/^$/ { exit }' | ${WORKDIR}/bin/fetchaddr -x From -a`"

    email="${head[(ws:,:)1]}"
    [[ "$email" = "" ]] && { return 1 }

    abook --datafile $MAILDIRS/whitelist.abook \
        --mutt-query "$email" > /dev/null
    return $?
}

learn() {
    func "learning ${PARAM[1]} in stdin piped mails"
    [[ $DRYRUN == 1 ]] && {
        func "dryrun parsing ${PARAM[1]} in stdin piped mails" }

    what=sender
    [[ "$1" = "" ]] || { what="$1" }
    func "learning from $what"

    # read in only headers from stdin (till empty line)
    buffer=`awk '{ print $0 } /^$/ { exit }'`

    case ${what} in

        sender|from) # simple: one address only on From:
            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -x From -a`"
            # (Q) eliminates quotes, then word split
            email="${(Q)head[(ws:,:)1]}"
            name="${(Q)head[(ws:,:)2]}"
            print "$head"
            [[ $DRYRUN == 1 ]] || {
                insert_address "$email" "$name"
                [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
            }
            return 0
            ;;

        all)
            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -a`"
            for h in ${(f)head}; do
                # (Q) eliminates quotes, then word split
                email="${(Q)h[(ws:,:)1]}"
                name="${(Q)h[(ws:,:)2]}"

                print "$h"

                [[ $DRYRUN == 1 ]] || {
                    insert_address "$email" "$name"
                    [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
                }
            done
            return 0
            ;;

        recipient|to) # complex: more addresses in To: and Cc:
            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -x To -a`"
            for h in ${(f)head}; do
                # (Q) eliminates quotes, then word split
                email="${(Q)h[(ws:,:)1]}"
                name="${(Q)h[(ws:,:)2]}"
                print "$h"

                [[ $DRYRUN == 1 ]] || {
                    insert_address "$email" "$name"
                    [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
                }
            done

            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -x Cc -a`"
            for h in ${(f)head}; do
                # (Q) eliminates quotes, then word split
                email="${(Q)h[(ws:,:)1]}"
                name="${(Q)h[(ws:,:)2]}"
                print "$h"

                [[ $DRYRUN == 1 ]] || {
                    insert_address "$email" "$name"
                    [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
                }
            done
            return 0
            ;;

        *)
            error "Unknown learning function: $what" ;;
    esac
    return 1

}

forget() {
    warning "forget() TODO in abook branch"
    return 0

    # func "forget sender from mail in stdin"
    # act "Expecting mail from stdin pipe"
    # head="`${WORKDIR}/bin/fetchaddr -x From -a`"
    # # forget the email part of the parsed head
    # remove_address "${head[(ws:,:)1]}"
}

# extract all addresses found in a list of email files from stdin
extract_mails() {
    _mails=`cat`
    # we switch dryrun temporarily off to use learn()
    # without modifying the addressbook
    _dryrun=$DRYRUN
    DRYRUN=1

    # learn from senders, recipients or all
    _action="$1"

    typeset -a learned
    for m in ${(f)_mails}; do
        _l=`hdr $m | learn $_action`
        # handles results on multiple lines (recipients, all)
        for ii in ${(f)_l}; do
            learned+=("$ii")
        done
    done

    DRYRUN=$_dryrun
    # eliminates duplicates
    typeset -A result
    for i in ${learned}; do
        _e=${i[(ws:,:)1]}
        [[ "${result[$_e]}" = "" ]] && {
            _n=${i[(ws:,:)2]}
            result+=("$_e" "$_n")
            print - "$_n <$_e>"
        }
    done
    notice "${#result} addresses extracted"
}

# extract all addresses found into a maildir
extract_maildir() {
    ## first arg is a directory
    md="$1"
    func "extract maildir: $md"
    ## extract from a maildir
    maildircheck "$md" || return 1
    
    _action="$2"
    case $_action in
        all) ;;
        recipient) ;;
        sender) ;;
        *) _action="all" ;;
    esac
    
    # search files
    _mails=`find $md -type f`
    # search symlinks
    _mails+=`find $md -type l`

    print - ${_mails} | extract_mails "$_action"
    return 0
}

# extract all entries in addressbook or all addresses in a pgp keyring
# or all signatures on a pgp key (even without importing it)
extract() {
    func "calling extract() $PARAM"

    # without arguments just list all entries in the active list
    # default is whitelist
    [[ "$1" = "" ]] && {
        func "extract all from list $list"
        awk -F'=' '
/^name/  { printf("%s ",$2)    }
/^email/ { printf("<%s>\n",$2) }
' "$MAILDIRS"/$list.abook
        return 0
    }


    [[ -r "$1" ]] && { # first arg is a file

        # a map to eliminate duplicates
        typeset -AU result
        
        # if first arg is a directory then extract from maildir
        [[ -d "$1" ]] && { 
            extract_maildir "$1" "$2"
            return $?
        }

        func "testing argument with file magic"
        _magic=`file "$1"`

        ######### GPG
        # first arg is a GnuPG key ring
        [[ "$_magic" =~ "GPG key public ring" ]] && {

            notice "Listing addresses found in GPG keyring: $1"
            _addrs=`gpg --list-keys --with-colons | awk -F: '{print $10}'`
            for i in ${(f)_addrs}; do
                _parsed=`print "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
                _e="${_parsed[(ws:,:)1]}"
                isemail "$_e"
                [[ $? = 0 ]] || continue
                # check if the email is not already parsed
                [[ "${result[$_e]}" = "" ]] && {
                    _n="${_parsed[(ws:,:)2]}"
                    result+=("$_e" "$_n")
                    print - "$_n <$_e>"
                }
            done

            notice "Unique addresses found: ${#result}"
            # counts which addresses are known to us
            _known=0
            for i in ${(k)result}; do
                lookup_email ${i}
                [[ $? = 0 ]] || {
                    _known=$(( $_known + 1 )) }
            done
            act "new addresses: $_known"
            return 0
        }

        # first arg is a GnuPG public key
        [[ "$_magic" =~ "PGP public key" ]] && {
            _gpg="gpg --no-default-keyring --keyring $MAILDIRS/cache/pubkey.gpg --batch --with-colons"
            rm -f $MAILDIRS/cache/pubkey.gpg
            ${=_gpg} --import "$1"
            # first make sure all unknown keys are imported
            _addrs=`${=_gpg} --list-sigs | awk -F: '{print $5 " " $10}'`
            for i in ${(f)_addrs}; do
                [[ "$i" =~ "[User ID not found]" ]] && {
                    act "looking up: $i"
                    ${=_gpg} --recv-key ${i[(w)1]}
                }
            done
            
            _addrs=`${=_gpg} --list-sigs | awk -F: '{print $10}'`
            for i in ${(f)_addrs}; do
                _parsed=`print "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
                _e="${_parsed[(ws:,:)1]}"
                isemail "$_e"
                [[ $? = 0 ]] || continue
                # check if the email is not already parsed
                [[ "${result[$_e]}" = "" ]] && {
                    _n="${_parsed[(ws:,:)2]}"
                    result+=("$_e" "$_n")
                    print - "$_n <$_e>"
                }
            done
            
            notice "Unique addresses found: ${#result}"
            # counts which addresses are known to us
            _known=0
            for i in ${(k)result}; do
                lookup_email ${i}
                [[ $? = 0 ]] || {
                    _known=$(( $_known + 1 )) }
            done
            act "new addresses: $_known"
            return 0
        }
    }

    func "extract from search query"

    # we switch dryrun temporarily off to use learn()
    # without modifying the addressbook
    _dryrun=$DRYRUN
    DRYRUN=1

    # run a search and list email files
    nm_search ${=PARAM} | extract_mails
}


# import an addressbook, autodetect its type
import_addressbook() {
    notice "Importing addressbook"
    func "$1"
    # a map to eliminate duplicates
    typeset -AU result

    # stdin
    [[ "$1" = "stdin" ]] && {
        act "reading entries from stdin"
        _stdin=`cat`
        _new=0
        for i in ${(f)_stdin}; do

            # skip comments starting with #
            [[ "$i[1]" = "#" ]] && continue

            _parsed=`print - "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
            _e="${_parsed[(ws:,:)1]}"

            # check if is really an email
            isemail "$_e"
            [[ $? = 0 ]] || continue

            # check if the email is not a duplicate
            [[ "${result[$_e]}" = "" ]] || continue

            _n="${_parsed[(ws:,:)2]}"
            result+=("$_e" "$_n")

            # check if the email is not already known
            lookup_email "$_e"
            [[ $? = 0 ]] && continue

            [[ $DRYRUN = 0 ]] && insert_address "$_e" "$_n"
            act "new entry imported: $_n <$_e>"
            _new=$(( $_new + 1 ))
        done
        notice "Valid unique entries parsed: ${#result}"
        act "new addresses found: ${_new}"
        return 0
    }

    if [[ "$1" != "" ]]; then
        func "file specified: $1"
        # a file was given as argument
        import_vcard "$1"
    else
        # no file as parameter
        { test "$OS" = "MAC" } && { import_macosx }
    fi
}


# import addressbook from Mac/OSX
import_macosx() {
    act "system addressbook from Mac/OSX"
    { test "$OS" = "MAC" } || { error "Not running on Mac/OSX, operation aborted." }
    { command -v ABQuery > /dev/null } || {
    error "ABQuery not found, operation aborted." }

    tmp=$TMPDIR/abook.import_osx.$datestamp.$RANDOM
    newlock $tmp

    # import all the Mac addressbook
    ABQuery @ | awk '
{ printf "%s|", $1; for(i=2;i<=NF;i++) { printf "%s ", $i } }
' >> $tmp
    addresses=`cat $tmp`
    unlink $tmp

    lock $ADDRESSBOOK
    new=0; dupes=0;
    for a in ${(f)addresses}; do
    _email="${a[(ws:|:)1]}"
    # remove from name all what is an email between brackets
    # crop (trim) all beginning and ending whitespaces from name
    _name=`print ${a[(ws:|:)2]} | sed 's/<.*>//;s/^[ \t]*//;s/[ \t]*$//'`
    insert_address ${_email} ${_name}
    if [ $? = 0 ]; then new=$(( $new + 1 ))
    else dupes=$(( $dupes + 1 )); fi
    done

    unlock $ADDRESSBOOK
    notice "Operation completed"
    act "$new new addresses imported"
    act "$dupes duplicate addresses skipped"
    return 0
}

# import emails from VCard into abook
# checks if the emails are already known
import_vcard() {
    act "import VCard from file: $1"

    [[ -r "$1" ]] || {
        error "File not found: $1"
        return 1
    }

    vcard="$1"
    head -n1 $vcard | grep '^BEGIN:VCARD' > /dev/null

    [[ $? = 0 ]] || {
        error "File to import is not a VCard: $vcard"
        return 1
    }

    notice "Import VCard in addressbook: ${vcard}"

    # parse the vcard and print a simple name and email list
    # each value on a single line, entry tuples followed by a #
    # we skip entries that don't have an email
    addresses=`cat ${vcard} | awk '
BEGIN { newcard=0; c=0; name=""; email=""; }
/^BEGIN:VCARD/ { newcard=1 }
/^FN:/ { if(newcard = 1) name=$0 }
/^EMAIL/ { if(newcard = 1) email=$0 }
/^END:VCARD/ {
  if(newcard = 1) {
    newcard=0
    if(email != "") {
      c+=1
      print name
      print email
      print "# " c
    }
    email=""
    next
  }
}
' | cut -d: -f2`

    # now parse the temporary list of name and emails
    # made of name, email and a hash for each, newline separated

    #    ${=rm} $tmp

    lock $ADDRESSBOOK

    newa=1; _name=""; _email=""
    for a in ${(f)addresses}; do
        { test "${a[1]}" = "#" } && {
            newa=1; # its the end of the entry

            # handle lines with multiple emails in vcard
            # TODO: generate Groups/${_name} from this
            for ee in ${=_email}; do
                # check if we have this email already
                _e=`print ${ee} | extract_emails`
                func "lookup_email: ${_e}"
                lookup_email "${_e}"

                [[ $? = 0 ]] || {
                    insert_address "${_e}" "${_name}"
                    act "${a} ${_name} <${_e}>"
                }
            done

            continue }
        if [[ $newa -eq 1 ]]; then
            # (V) makes special chars visible, we need to remove them..
            _name="${(V)a[(ws:^:)1]}"; newa=0; continue
        elif [[ $newa -eq 0 ]]; then
            _email="${(V)a[(ws:^:)1]}"
        fi
    done

    unlock $ADDRESSBOOK

    notice "Done importing addresses"
}

# export old addressbook format to abook
export_abook() {

    [[ -r $MAILDIRS/Addressbook ]] || {
        notice "Old addressbook format not found"
        act "there is nothing to convert to abook"
        return 1
    }

    lock $MAILDIRS/Addressbook

    out=$MAILDIRS/$list.abook
    act "Exporting $list to abook format: $out"
    rm -f $out

    func "launching SELECT email,name sqlite3 query"
    addresses=`cat <<EOF | ${SQL} -column -header -batch $MAILDIRS/Addressbook \
    | grep -v '^email'
.width 40 100
.mode list
.separator '|'
SELECT email, name FROM $list;
EOF`

    unlock $MAILDIRS/Addressbook
    func "converting database into abook format"
    cat <<EOF > $out
# abook addressbook file

[format]
program=JaroMail
version=$VERSION

EOF
    c=0
    for a in ${(f)addresses}; do
        _email="${(Q)a[(ws:|:)1]}"
        # remove from name all what is an email between brackets
        # crop (trim) all beginning and ending whitespaces from name
        _name=`print ${(Q)a[(ws:|:)2]} | trim`
        { test "${_email}" != "" } && {
            cat <<EOF >> $out
[${c}]
name=${_name}
email=${_email}

EOF
            c=$(( $c + 1 ))
        }
    done

}

# export addressbook to vcard
export_vcard() {
    abook --convert --informat abook \
        --infile "$ADDRESSBOOK" \
        --outformat gcrd --outfile "$MAILDIRS"/$list.vcf
    return $?
}

edit_abook() {

    abook --config <(cat <<EOF
set autosave=true
set mutt_command=jaro compose
set sort_field=name
EOF
) --datafile "$ADDRESSBOOK"
}
###################
