#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



###################
# Jaro Brother DB
create_addressbook() {
    # $ADDRESSBOOK is set in jaro
    ab="$ADDRESSBOOK"
    func "create addressbook: $ab"
    [[ -r "$ab" ]] && {
        error "Addressbook already exists: $ab"
        return 1
    }

    [[ -r "$MAILDIRS"/Addressbook ]] && {
        notice "Updating the old addressbook to a new format"
        _list=$list
        list=blacklist; export_abook
        list=whitelist; export_abook
        list=$_list
        mv "$MAILDIRS"/Addressbook "$MAILDIRS"/Addressbook.old 
    }

    touch "$ab"

    # make sure is private
    chmod 600 "$ab"
    chown $_uid:$_gid "$ab"

    return 0
}

insert_address() {
    _email="${1}"; _name="${2}";
    func "insert address: $_name <$_email>"

    lookup_email "$_email"

    [[ $? = 0 ]] && {
        func "address already present in $list"
        return 1
    }

    print "From: $_name <$_email>" | \
        abook --datafile "$ADDRESSBOOK" \
        --add-email-quiet > /dev/null

    return 0
}

search_addressbook() {
    func "search \"$@\" in $list"
    abook --datafile "$ADDRESSBOOK" --mutt-query "${@:l}"
}


lookup_email() {
    _addr=${1:l}
    func "lookup address $_addr in $list"
    abook --datafile "$ADDRESSBOOK" \
        --mutt-query "$_addr" > /dev/null
    return $?
}

complete() {
    func "complete: $1 (list $list)"

    # completion on configured groups
    { test -r "$MAILDIRS/Groups" } && {
        if [[ "$1" =~ "group/" ]]; then
            func "completion will look into groups"
            needle="${1[(ws:/:)2]}"
            if [ "$needle" = "" ]; then
                act "Listing all mailout groups"
                matches=`${=find} "$MAILDIRS/Groups" -type f`
            else
                act "Searching for \"$needle\" in mailout groups"
                matches=`${=find} "$MAILDIRS/Groups" -type f -name \"*$needle*\"`
            fi

            print "Groups: `print $matches | wc -l` matches"
            print
            for i in ${(f)matches}; do
                gr=`basename $i`
                print "$gr@jaromail.group\t`wc -l < $i` recipients"
            done
            return 0
        fi
    }

    act "Searching for \"$1\" in addressbook $list"
    abook --datafile "$ADDRESSBOOK" --mutt-query "$1"
    return $?
}

sender_isknown() {
    # extract only headers from stdin
    head="`awk '
{ print $0 }
/^$/ { exit }' | ${WORKDIR}/bin/fetchaddr -x From -a`"

    email="${head[(ws:,:)1]:l}"
    isemail $email
    [[ $? = 0 ]] || { return 1 }

    abook --datafile $MAILDIRS/$list.abook \
        --mutt-query "$email" > /dev/null
    return $?
}

learn() {
    func "learning ${PARAM[1]} in stdin piped mails"
    [[ $DRYRUN == 1 ]] && func "running in dryrun mode, no entries added to addressbook"

    what=sender
    [[ "$1" = "" ]] || { what="$1" }
    func "learning from $what"

    case ${what} in

        sender|from) # simple: one address only on From:

            # now e_name e_mail and e_parsed are filled in
            awk '{ print $0 } /^$/ { exit }' | e_parse From
            
            # no need to cycle, From is always only one field
            [[ $DRYRUN == 0 ]] && {
                _e="${(k)e_addr}"
                _n="${(v)e_addr}"
                insert_address "$_e" "$_n"
                [[ $? = 0 ]] && { act "$list <- $_n <$_e>" }
            }
            return 0
            ;;

        all)

            awk '{ print $0 } /^$/ { exit }' | e_parse

            [[ $DRYRUN == 0 ]] && {
                # complex: more addresses in To: and Cc:
                for _e in ${(k)e_addr}; do
                    _n="${e_addr[$_e]}"
                    insert_address "$_e" "$_n"
                    [[ $? = 0 ]] && { act "$list <- $_n <${_e}>" }
                done
            }
            return 0
            ;;
        
        recipient|to)

            awk '{ print $0 } /^$/ { exit }' | e_parse To

            [[ $DRYRUN == 0 ]] && {
                # complex: more addresses in To: and Cc:
                for _e in ${(k)e_addr}; do
                    _n="${e_addr[$_e]}"
                    insert_address "$_e" "$_n"
                    [[ $? = 0 ]] && { act "$list <- $_n <${_e}>" }
                done
            }

            e_parse Cc

            [[ $DRYRUN == 0 ]] && {
                # complex: more addresses in To: and Cc:
                for _e in ${(k)e_addr}; do
                    _n="${e_addr[$_e]}"
                    insert_address "$_e" "$_n"
                    [[ $? = 0 ]] && { act "$list <- $_n <${_e}>" }
                done
            }

            return 0
            ;;
        
        *)
            error "Unknown learning function: $what" ;;
    esac
    return 1

}

forget() {
    error "forget() TODO in abook branch"
    return 0

    # func "forget sender from mail in stdin"
    # act "Expecting mail from stdin pipe"
    # head="`${WORKDIR}/bin/fetchaddr -x From -a`"
    # # forget the email part of the parsed head
    # remove_address "${head[(ws:,:)1]}"
}

# extract all addresses found in a list of email files from stdin
extract_mails() {
    _mails=`cat`

    _tot=`print $_mails | wc -l`
    act "$_tot emails to parse"

    [[ $_tot -gt 100 ]] && {
        act "operation will take a while, showing progress"
        _prog=0
        c=0
    }

    # learn from senders, recipients or all
    _action="$1"


    # -U eliminates duplicates
    typeset -aU _res

    for m in ${(f)_mails}; do

        # e_parse fills in e_addr(map) and e_parsed(newline term str)
        hdr $m | e_parse $_action
        for _e in ${(k)e_addr}; do
            _res+=("${(v)e_addr[$_e]} <$_e>")
        done
        
        [[ $_tot -gt 100 ]] && {
            c=$(( $c + 1 ))
            [[ $c -gt 99 ]] && {
                _prog=$(( $_prog + $c ))
                act "$_prog / $_tot processed so far"
                c=1
            }
        }
    done
    # print out results
    for r in $_res; do
        print - $r
    done
    notice "${#_res} unique addresses extracted"
}

# extract all addresses found into a maildir
extract_maildir() {
    ## first arg is a directory
    md="$1"
    func "extract maildir: $md"
    ## extract from a maildir
    maildircheck "$md" || return 1
    
    _action="$2"
    case $_action in
        all) ;;
        recipient) ;;
        sender) ;;
        *) _action="all" ;;
    esac
    
    # search files
    _mails=`find $md -type f`
    # search symlinks
    _mails+=`find $md -type l`

    print - ${_mails} | extract_mails "$_action"
    return 0
}


# import emails from VCard into abook
# checks if the emails are already known
import_vcard() {
    act "import VCard from file: $1"

    [[ -r "$1" ]] || {
        error "File not found: $1"
        return 1
    }

    vcard="$1"
    head -n1 $vcard | grep '^BEGIN:VCARD' > /dev/null

    [[ $? = 0 ]] || {
        error "File to import is not a VCard: $vcard"
        return 1
    }

    notice "Import VCard in addressbook: ${vcard}"

    # parse the vcard and print a simple name and email list
    # each value on a single line, entry tuples followed by a #
    # we skip entries that don't have an email
    addresses=`cat ${vcard} | awk '
BEGIN { newcard=0; c=0; name=""; email=""; }
/^BEGIN:VCARD/ { newcard=1 }
/^FN:/ { if(newcard = 1) name=$0 }
/^EMAIL/ { if(newcard = 1) email=$0 }
/^END:VCARD/ {
  if(newcard = 1) {
    newcard=0
    if(email != "") {
      c+=1
      print name
      print email
      print "# " c
    }
    email=""
    next
  }
}
' | cut -d: -f2`

    # now parse the temporary list of name and emails
    # made of name, email and a hash for each, newline separated

    #    ${=rm} $tmp

    lock $ADDRESSBOOK

    newa=1; _name=""; _email=""
    for a in ${(f)addresses}; do
        { test "${a[1]}" = "#" } && {
            newa=1; # its the end of the entry

            # handle lines with multiple emails in vcard
            # TODO: generate Groups/${_name} from this
            for ee in ${=_email}; do
                # check if we have this email already
                _e=`print ${ee} | extract_emails`
                func "lookup_email: ${_e}"
                lookup_email "${_e}"

                [[ $? = 0 ]] || {
                    insert_address "${_e}" "${_name}"
                    act "${a} ${_name} <${_e}>"
                }
            done

            continue }
        if [[ $newa -eq 1 ]]; then
            # (V) makes special chars visible, we need to remove them..
            _name="${(V)a[(ws:^:)1]}"; newa=0; continue
        elif [[ $newa -eq 0 ]]; then
            _email="${(V)a[(ws:^:)1]}"
        fi
    done

    unlock $ADDRESSBOOK

    notice "Done importing addresses"
}

# extract all entries in addressbook or all addresses in a pgp keyring
# or all signatures on a pgp key (even without importing it)
extract() {
    func "extract() $PARAM"

    # without arguments just list all entries in the active list
    # default is whitelist

    arg=${PARAM[1]}

    func "extract() arg: $arg (param: $PARAM)"

    # no arg means print all entries from adressbook
    [[ "$arg" = "" ]] && {
        notice "Extracting all addresses in $list"
        awk -F'=' '
/^name/  { printf("%s ",$2)    }
/^email/ { printf("<%s>\n",$2) }
' $ADDRESSBOOK
        return 0
    }


    [[ -r "$arg" ]] && {
        # if first arg is a file, could be a maildir, a gpg keyring,
        # a gpg pubkey or a vcard
        
        # if first arg is a directory then extract from maildir
        [[ -d "$arg" ]] && {
            notice "Extracting $2 addresses from maildir $1"
            extract_maildir "$1" "$2"
            return $?
        }

        func "testing argument with file magic"
        _magic=`file "$arg"`

        # a map to eliminate duplicates
        typeset -AU result

        ######### GPG
        # first arg is a GnuPG key ring
        [[ "$_magic" =~ "GPG key public ring" ]] && {

            notice "Extracting addresses found in GPG keyring: $arg"
            _addrs=`gpg --list-keys --with-colons | awk -F: '{print $10}'`
            for i in ${(f)_addrs}; do
                _parsed=`print "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
                _e="${_parsed[(ws:,:)1]:l}"
                isemail "$_e"
                [[ $? = 0 ]] || continue
                # check if the email is not already parsed
                [[ "${result[$_e]}" = "" ]] && {
                    _n="${_parsed[(ws:,:)2]}"
                    result+=("$_e" "$_n")
                    print - "$_n <$_e>"
                }
            done

            notice "Unique addresses found: ${#result}"
            # counts which addresses are known to us
            _known=0
            for i in ${(k)result}; do
                lookup_email ${i}
                [[ $? = 0 ]] || {
                    _known=$(( $_known + 1 )) }
            done
            act "new addresses: $_known"
            return 0
        }

        # first arg is a GnuPG public key
        [[ "$_magic" =~ "PGP public key" ]] && {
            notice "Extracting addresses from sigs on GPG key $arg"
            _gpg="gpg --no-default-keyring --keyring $MAILDIRS/cache/pubkey.gpg --batch --with-colons"
            ${=rm} $MAILDIRS/cache/pubkey.gpg
            ${=_gpg} --import "$arg"
            # first make sure all unknown keys are imported
            _addrs=`${=_gpg} --list-sigs | awk -F: '{print $5 " " $10}'`
            for i in ${(f)_addrs}; do
                [[ "$i" =~ "[User ID not found]" ]] && {
                    act "looking up: $i"
                    ${=_gpg} --recv-key ${i[(w)1]}
                }
            done
            
            _addrs=`${=_gpg} --list-sigs | awk -F: '{print $10}'`
            for i in ${(f)_addrs}; do
                _parsed=`print "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
                _e="${_parsed[(ws:,:)1]:l}"
                isemail "$_e"
                [[ $? = 0 ]] || continue
                # check if the email is not already parsed
                [[ "${result[$_e]}" = "" ]] && {
                    _n="${_parsed[(ws:,:)2]}"
                    result+=("$_e" "$_n")
                    print - "$_n <$_e>"
                }
            done
            
            notice "Unique addresses found: ${#result}"
            # counts which addresses are known to us
            _known=0
            for i in ${(k)result}; do
                lookup_email ${i}
                [[ $? = 0 ]] || {
                    _known=$(( $_known + 1 )) }
            done
            act "new addresses: $_known"
            return 0
        }
    }

    # if no file is recognized, use string as search query
    notice "Extracting addresses from search query: $PARAM"
    
    # run a search and list email files
    nm_search ${=PARAM} | extract_mails
}


# import address lists from stdin
import() {

    # case insensitive match
    unsetopt CASE_MATCH

    _arg=${PARAM[1]}

    func "import() arg: $_arg (param: $PARAM)"
    # a map to eliminate duplicates
    typeset -AU result

    [[ "$_arg" = "" ]] && {
        notice "Import address list from stdin into addressbook $list"
        _stdin=`cat`
        _new=0
        act "imported new entries will be printed on stdout"
        for i in ${(f)_stdin}; do
            # skip comments starting with #
            [[ "$i[1]" = "#" ]] && continue
            
            _parsed=`print - "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
            _e="${_parsed[(ws:,:)1]:l}"
            
            # check if is really an email
            isemail "$_e"
            [[ $? = 0 ]] || {
                func "not an email: $_e"
                continue
            }

            # check if the email is not a duplicate
            [[ "${result[$_e]}" = "" ]] || {
                func "duplicate email: $_e"
                continue
            }
            
            _n="${_parsed[(ws:,:)2]}"
            result+=("$_e" "$_n")
            
            # check if the email is not already known
            lookup_email "$_e"
            [[ $? = 0 ]] && {
                func "email already known: $_e"
                continue
            }

            print - "$_n <$_e>"            
            [[ $DRYRUN = 0 ]] && insert_address "$_e" "$_n"

            _new=$(( $_new + 1 ))
        done
        notice "Valid unique entries parsed: ${#result}"
        act "new addresses found: ${_new}"
        return $?
    }

    [[ -r "$_arg" ]] && {
        notice "Import address list from stdin into group file $arg"
        act "parsing entries in group file"
        _group=`cat $arg`
        for i in ${(f)_group}; do
            # skip comments starting with #
            [[ "$i[1]" = "#" ]] && continue
            
            _parsed=`print - "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
            _e="${_parsed[(ws:,:)1]:l}"
            
            # check if is really an email
            isemail "$_e"
            [[ $? = 0 ]] || {
                func "not an email: $_e"
                continue
            }

            # check if the email is a duplicate
            [[ "${result[$_e]}" = "" ]] || {
                func "duplicate email: $_e"
                continue
            }
            
            _n="${_parsed[(ws:,:)2]}"
            result+=("$_e" "$_n")            
        done

        # imported all group file contents in results
        notice "${#result} entries parsed in $arg"
        act "reading entries from stdin, printing out new entries"
        
        _stdin=`cat`
        _new=0
        for i in ${(f)_stdin}; do
            # skip comments starting with #
            [[ "$i[1]" = "#" ]] && continue
            
            _parsed=`print - "From: $i" | ${WORKDIR}/bin/fetchaddr -a -x from`
            _e="${_parsed[(ws:,:)1]:l}"
            
            # check if is really an email
            isemail "$_e"
            [[ $? = 0 ]] || {
                func "not an email: $_e"
                continue
            }

            # check if the email is a duplicate
            [[ "${result[$_e]}" = "" ]] || {
                func "duplicate email: $_e"
                continue
            }

            _n="${_parsed[(ws:,:)2]}"
            result+=("$_e" "$_n")

            print - "$_n <$_e>"            
            _new=$(( $_new + 1 ))
        done
        # TODO: overwrite group file with all entries
        notice "Valid unique entries parsed: ${#result}"
        act "new addresses found: ${_new}"

    }

    return 0
}



# export old addressbook format to abook
export_abook() {

    [[ -r $MAILDIRS/Addressbook ]] || {
        notice "Old addressbook format not found"
        act "there is nothing to convert to abook"
        return 1
    }

    lock $MAILDIRS/Addressbook

    out=$MAILDIRS/$list.abook
    act "Exporting $list to abook format: $out"
    rm -f $out

    func "launching SELECT email,name sqlite3 query"
    addresses=`cat <<EOF | ${SQL} -column -header -batch $MAILDIRS/Addressbook \
    | grep -v '^email'
.width 40 100
.mode list
.separator '|'
SELECT email, name FROM $list;
EOF`

    unlock $MAILDIRS/Addressbook
    func "converting database into abook format"
    cat <<EOF > $out
# abook addressbook file

[format]
program=JaroMail
version=$VERSION

EOF
    c=0
    for a in ${(f)addresses}; do
        _email="${(Q)a[(ws:|:)1]}"
        # remove from name all what is an email between brackets
        # crop (trim) all beginning and ending whitespaces from name
        _name=`print ${(Q)a[(ws:|:)2]} | trim`
        { test "${_email}" != "" } && {
            cat <<EOF >> $out
[${c}]
name=${_name}
email=${_email}

EOF
            c=$(( $c + 1 ))
        }
    done

}

# export addressbook to vcard
export_vcard() {
    abook --convert --informat abook \
        --infile "$ADDRESSBOOK" \
        --outformat gcrd --outfile "$MAILDIRS"/$list.vcf
    return $?
}

edit_abook() {

    abook --config <(cat <<EOF
set autosave=true
set mutt_command=jaro compose
set sort_field=name
EOF
) --datafile "$ADDRESSBOOK"
}
###################
