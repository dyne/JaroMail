#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



###################
# Jaro Brother DB
create_addressbook() {
    ab="$ADDRESSBOOK"
    func "create addressbook: $ab"
    [[ -r "$ab" ]] && {
        error "Addressbook already exists: $ab"
        return 1
    }

    touch "$ab"

    # make sure is private
    chmod 600 "$ab"
    chown $_uid:$_gid "$ab"

    return 0
}

insert_address() {
    _email="${1}"; _name="${2}";
    func "insert address: $_name <$_email>"

    lookup_email "$_email"

    [[ $? = 0 ]] && {
        func "address already present in $list"
        return 1
    }
     
    print "From: $_name <$_email>" | \
        abook --datafile "$ADDRESSBOOK" \
        --add-email-quiet

    return 0
}

# update_name() {
#     func "update address: $1, $2"
#     cat <<EOF | ${SQL} -batch $ADDRESSBOOK 2> /dev/null
# UPDATE $list SET name="${2}" WHERE email LIKE "${1}";
# EOF
#     { test $? != 0 } && {
#   func "address not found or error occurred" }
# }

remove_address() {
    warning "remove_address() TODO in abook branch"
    return 0
}

search_addressbook() {
    func "search \"$1\" in $list"
    abook --datafile "$ADDRESSBOOK" --mutt-query "$1"
}


lookup_email() {
    func "lookup email $1 in $list"
    abook --datafile "$ADDRESSBOOK" \
        --mutt-query "$1" > /dev/null
    return $?
}

complete() {
    func "complete: $1 (list $list)"

    # completion on configured groups
    { test -r "$MAILDIRS/Groups" } && {
        if [[ "$1" =~ "group/" ]]; then
            func "completion will look into groups"
            needle="${1[(ws:/:)2]}"
            if [ "$needle" = "" ]; then
                act "Listing all mailout groups"
                matches=`${=find} "$MAILDIRS/Groups" -type f`
            else
                act "Searching for \"$needle\" in mailout groups"
                matches=`${=find} "$MAILDIRS/Groups" -type f -name \"*$needle*\"`
            fi
            print "Groups: `print $matches | wc -l` matches"
            print
            for i in ${(f)matches}; do
                gr=`basename $i`
                print "$gr@jaromail.group\t`wc -l < $i` recipients"
            done
            return 0
        fi
    }

    act "Searching for \"$1\" in addressbook $list"
    abook --datafile "$ADDRESSBOOK" --mutt-query "$1"
    return $?
}

sender_isknown() {
    # extract only headers from stdin
    head="`awk '
{ print $0 }
/^$/ { exit }' | ${WORKDIR}/bin/fetchaddr -x From -a`"

    email="${head[(ws:,:)1]}"
    [[ "$email" = "" ]] && { return 1 }

    abook --datafile $MAILDIRS/whitelist.abook \
        --mutt-query "$email" > /dev/null
    return $?
}

learn() {
    func "learning ${PARAM[1]} in stdin piped mails"
    [[ $DRYRUN == 1 ]] && {
        func "dryrun parsing ${PARAM[1]} in stdin piped mails" }

    what=sender
    [[ "$1" = "" ]] || { what="$1" }
    func "learning from $what"

    # read in only headers from stdin (till empty line)
    buffer=`awk '{ print $0 } /^$/ { exit }'`

    case ${what} in

        sender) # simple: one address only on From:
            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -x From -a`"
            # (Q) eliminates quotes, then word split
            email="${(Q)head[(ws:,:)1]}"
            name="${(Q)head[(ws:,:)2]}"
            print "$head"
            [[ $DRYRUN == 1 ]] || {
                insert_address "$email" "$name"
                [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
            }
            return 0
            ;;

        all)
            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -a`"
            for h in ${(f)head}; do
                # (Q) eliminates quotes, then word split
                email="${(Q)h[(ws:,:)1]}"
                name="${(Q)h[(ws:,:)2]}"

                print "$h"

                [[ $DRYRUN == 1 ]] || {
                    insert_address "$email" "$name"
                    [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
                }
            done
            return 0
            ;;

        recipient) # complex: more addresses in To: and Cc:
            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -x To -a`"
            for h in ${(f)head}; do
                # (Q) eliminates quotes, then word split
                email="${(Q)h[(ws:,:)1]}"
                name="${(Q)h[(ws:,:)2]}"
                print "$h"

                [[ $DRYRUN == 1 ]] || {
                    insert_address "$email" "$name"
                    [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
                }
            done

            head="`print $buffer | ${WORKDIR}/bin/fetchaddr -x Cc -a`"
            for h in ${(f)head}; do
                # (Q) eliminates quotes, then word split
                email="${(Q)h[(ws:,:)1]}"
                name="${(Q)h[(ws:,:)2]}"
                print "$h"

                [[ $DRYRUN == 1 ]] || {
                    insert_address "$email" "$name"
                    [[ $? = 0 ]] && { act "new: $_name <${_email}>" }
                }
            done
            return 0
            ;;

        *)
            error "Unknown learning function: $what" ;;
    esac
    return 1

}

forget() {
    warning "forget() TODO in abook branch"
    return 0

    # func "forget sender from mail in stdin"
    # act "Expecting mail from stdin pipe"
    # head="`${WORKDIR}/bin/fetchaddr -x From -a`"
    # # forget the email part of the parsed head
    # remove_address "${head[(ws:,:)1]}"
}

# import an addressbook, autodetect its type
import_addressbook() {
    notice "Importing addressbook"
    if [ "${PARAM[1]}" != "" ]; then
        func "file specified: ${PARAM[1]}"
        # a file was given as argument
        import_vcard ${PARAM[2]}
    else
        # no file as parameter
        { test "$OS" = "MAC" } && { import_macosx }
    fi
}


# import addressbook from Mac/OSX
import_macosx() {
    act "system addressbook from Mac/OSX"
    { test "$OS" = "MAC" } || { error "Not running on Mac/OSX, operation aborted." }
    { command -v ABQuery > /dev/null } || {
    error "ABQuery not found, operation aborted." }

    tmp=$TMPDIR/abook.import_osx.$datestamp.$RANDOM
    newlock $tmp

    # import all the Mac addressbook
    ABQuery @ | awk '
{ printf "%s|", $1; for(i=2;i<=NF;i++) { printf "%s ", $i } }
' >> $tmp
    addresses=`cat $tmp`
    unlink $tmp

    lock $ADDRESSBOOK
    new=0; dupes=0;
    for a in ${(f)addresses}; do
    _email="${a[(ws:|:)1]}"
    # remove from name all what is an email between brackets
    # crop (trim) all beginning and ending whitespaces from name
    _name=`print ${a[(ws:|:)2]} | sed 's/<.*>//;s/^[ \t]*//;s/[ \t]*$//'`
    insert_address ${_email} ${_name}
    if [ $? = 0 ]; then new=$(( $new + 1 ))
    else dupes=$(( $dupes + 1 )); fi
    done

    unlock $ADDRESSBOOK
    notice "Operation completed"
    act "$new new addresses imported"
    act "$dupes duplicate addresses skipped"
    return 0
}

# import emails from VCard into abook
# checks if the emails are already known
import_vcard() {
    act "import VCard from file: $1"

    [[ -r "$1" ]] || {
        error "File not found: $1"
        return 1
    }

    vcard="$1"
    head -n1 $vcard | grep '^BEGIN:VCARD' > /dev/null

    [[ $? = 0 ]] || {
        error "File to import is not a VCard: $vcard"
        return 1
    }

    notice "Import VCard in addressbook: ${vcard}"

    # parse the vcard and print a simple name and email list
    # each value on a single line, entry tuples followed by a #
    # we skip entries that don't have an email
    addresses `cat ${vcard} | awk '
BEGIN { newcard=0; c=0; name=""; email=""; }
/^BEGIN:VCARD/ { newcard=1 }
/^FN:/ { if(newcard = 1) name=$0 }
/^EMAIL/ { if(newcard = 1) email=$0 }
/^END:VCARD/ {
  if(newcard = 1) {
    newcard=0
    if(email != "") {
      c+=1
      print name
      print email
      print "# " c
    }
    email=""
    next
  }
}
' | cut -d: -f2`

    # now parse the temporary list of name and emails
    # made of name, email and a hash for each, newline separated

    #    ${=rm} $tmp

    lock $ADDRESSBOOK

    newa=1; _name=""; _email=""
    for a in ${(f)addresses}; do
        { test "${a[1]}" = "#" } && {
            newa=1; # its the end of the entry

            # handle lines with multiple emails in vcard
            # TODO: generate Groups/${_name} from this
            for ee in ${=_email}; do
                # check if we have this email already
                _e=`print ${ee} | extract_emails`
                func "lookup_email: ${_e}"
                lookup_email "${_e}"

                [[ $? = 0 ]] || {
                    insert_address "${_e}" "${_name}"
                    act "${a} ${_name} <${_e}>"
                }
            done

            continue }
        if [[ $newa -eq 1 ]]; then
            # (V) makes special chars visible, we need to remove them..
            _name="${(V)a[(ws:^:)1}"; newa=0; continue
        elif [[ $newa -eq 0 ]]; then
            _email="${(V)a[(ws:^:)1}"
        fi
    done

    unlock $ADDRESSBOOK

    notice "Done importing addresses"
}

# export addressbook to vcard
export_vcard() {
    abook --convert --informat abook \
        --infile "$ADDRESSBOOK" \
        --outformat gcrd --outfile "$MAILDIRS"/$list.vcf
    return $?
}

edit_abook() {

    abook --config <(cat <<EOF
set autosave=true
set mutt_command=jaro
set sort_field=name
EOF
) --datafile $MAILDIRS/$list.abook
}
###################
