#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyright (C) 2017-2021 Dyne.org Foundation
#
# JaroMail is designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


is_mutt_notmuch() {
	fn is_mutt_notmuch
	req=(MAILDIRS mutt_exec)
	ckreq || return 1

    rm -f "$MAILDIRS/.mutt/notmuch"
    touch "$MAILDIRS/.mutt/notmuch"
    res=`${mutt_exec} -v | awk '/Configure options.*notmuch/ { print $0 }'`
    [[ "$res" = "" ]] || return 0
    act "Notmuch support not found in mutt, disabling extra features"
    return 1
}

use_notmuch() {
	fn is_notmuch
	req=(MAILDIRS subcommand)
	ckreq || return 1
	[[ -r "$MAILDIRS"/cache/notmuch/rc ]] &&
		[[ "$subcommand" != "peek" ]]
}

x_mutt() {
	fn x_mutt $*
	req=(MAILDIRS WORKDIR mutt_exec)
	ckreq || return 1

	# main conf
    ${=mkdir} "$MAILDIRS/.mutt"
    ${=mkdir} "$MAILDIRS/.mutt"/cache
    rm -f "$MAILDIRS/.mutt"/rc


	# detect the default gpg key to always encrypt also to self
	# update: do not re-encrypt if already done
	gpgkey=""
	[[ -r $HOME/.gnupg/gpg.conf ]] && {
		gpgkey=`awk '/^default-key/ { print $2 }' $HOME/.gnupg/gpg.conf`
		act "GPG key in use: $gpgkey"
	}

    cat<<EOF > "$MAILDIRS/.mutt"/rc
#### Mutt config automatically generated by Jaro Mail
### do not edit: this file is overwritten by jaro update
### put your customizations in Mail/Accounts/default.txt
### using my_hdr

unset use_domain
set folder = '$MAILDIRS'
set spoolfile = '$MAILDIRS/known/'
set record = '$MAILDIRS/sent/'
set postponed= '$MAILDIRS/postponed/'
set tmpdir = '$MAILDIRS/.mutt/cache'
set sendmail = "$WORKDIR/bin/jaro -q queue"
set header_cache= '$MAILDIRS/.mutt/cache'
set message_cachedir = '$MAILDIRS/.mutt/cache
set editor = "$WORKDIR/bin/jaro -q edit"
set mailcap_path = "$MAILDIRS/.mutt/mailcap:$MAILDIRS/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q complete '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn sender<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn all<enter>" "add all addresses in whitelist"
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn sender<enter>" "add sender to blacklist"


# specific configuration files
source '$WORKDIR/mutt/gpg'
source '$WORKDIR/mutt/crypto'
source '$WORKDIR/mutt/general'
source '$WORKDIR/mutt/formats'
source '$WORKDIR/mutt/keybindings'
source '$WORKDIR/mutt/colors'

# identity built parsing accounts (using myhdr)
source '$MAILDIRS/.mutt/identity'

# pointer to password tempfile and dynamic settings
# must be before mboxes to set folder on imap peek
source '$MAILDIRS/.mutt/muttpass'

# mailboxes in order of priority
source '$MAILDIRS/.mutt/mboxes'

# extra settings for mutt-kz (notmuch enabled)
source '$MAILDIRS/.mutt/notmuch'

# crypto support
source '$MAILDIRS/.mutt/crypto'
EOF

	# identity
	rm -f "$MAILDIRS/.mutt/identity"
	touch "$MAILDIRS/.mutt/identity"
	cat <<EOF > $MAILDIRS/.mutt/identity
set realname = '$name'
set from = '${name} <${email}>'
EOF
	[[ "$gpgkey" = "" ]] ||
		print "set pgp_sign_as = '${gpgkey}'" >> $MAILDIRS/.mutt/identity
	[[ -r ~/.signature ]] &&
		print "set signature = '~/.signature'" >> $MAILDIRS/.mutt/identity
	[[ "$my_hdr" = "" ]] ||
		print "$my_hdr" >> $MAILDIRS/.mutt/identity


	rm -f "$MAILDIRS/.mutt/crypto"
	touch "$MAILDIRS/.mutt/crypto"

	# support opmux or fallback to gpgewrap
	cryptowrap=$(command -v opmux)
	if [[ "$cryptowrap" == "" ]]; then
		cryptowrap=${WORKDIR}/bin/gpgewrap
		cat <<EOF >> "$MAILDIRS/.mutt/crypto"
# Generated by JaroMail at every execution
# create a pgp/mime encrypted attachment
set pgp_list_pubring_command="gpg --no-verbose --batch --with-colons --list-keys %r"
set pgp_self_encrypt = yes
set pgp_use_gpg_agent = yes
set pgp_encrypt_only_command="${cryptowrap} gpg --batch --quiet --no-verbose --output - --encrypt --textmode --armor --always-trust --encrypt-to $gpgkey -- -r %r -- '%f'"
set pgp_encrypt_sign_command="${cryptowrap} gpg %?p?--passphrase-fd 0? --batch --quiet --no-verbose --textmode --output - --encrypt --sign %?a?-u %a? --armor --always-trust --encrypt-to $gpgkey -- -r %r -- '%f'"
EOF
	else
		# OPMUX
		cat <<EOF >> "$MAILDIRS/.mutt/crypto"
# Generated by JaroMail at every execution
set pgp_long_ids

set pgp_decode_command="OPMUX_MUA=mutt ${cryptowrap} --passphrase-fd 0 \
	--quiet --batch --output - %f"
set pgp_verify_command="OPMUX_MUA=mutt ${cryptowrap} --quiet --batch \
	--output - --verify %s %f"
set pgp_decrypt_command="OPMUX_MUA=mutt ${cryptowrap} --passphrase-fd 0 \
	--quiet --batch --output - %f"

set pgp_encrypt_only_command="${cryptowrap} --batch --quiet --output - \
	--encrypt --textmode --armor --always-trust -r '%r' %f"
set pgp_encrypt_sign_command="${cryptowrap} --passphrase-fd 0 --batch \
	--quiet --textmode --output - --encrypt --sign %?a?-u %a? --armor \
	--always-trust -r '%r' %f"

set pgp_list_pubring_command="${cryptowrap} --batch --quiet --with-colons \
	--list-keys %r"
EOF
	fi

	unset cryptowrap

    # MUTT MAILCAP

# 	# charset conversion
#     cat <<EOF > $MAILDIRS/.mutt/mailcap
# text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
#   && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
# text/plain; cat %s
# EOF

# 	# HTML conversion
wwwtext=w3m
if command -v elinks > /dev/null; then
cat <<EOF >> $MAILDIRS/.mutt/mailcap
text/html; elinks -dump -dump-charset %{charset} %s; nametemplate=%s.html; copiousoutput
EOF
elif command -v w3m > /dev/null; then
cat <<EOF >> $MAILDIRS/.mutt/mailcap
text/html; w3m -I %{charset} -T text/html %s; nametemplate=%s.html; copiousoutput
EOF
elif command -v lynx > /dev/null; then
cat <<EOF >> $MAILDIRS/.mutt/mailcap
text/html; lynx -dump -assume_charset=%{charset} %s; nametemplate=%s.html; copiousoutput
EOF
fi

## TODO: import into gcal?
	command -v vcal > /dev/null && {
		# VCAL conversion
	cat <<EOF >> $MAILDIRS/.mutt/mailcap
text/calendar; vcal --all %s; nametemplate=%s.vcal; copiousoutput
EOF
	}

    { test -r "${MAILDIRS}/Applications.txt" } && {

        # here is the tweak to open attachments
        # with Mutt without blocking it (fork)

        apptypes=`cat "${MAILDIRS}/Applications.txt"`
        for t in ${(f)apptypes}; do
            eval `print $t | awk '
    { print "_type=" $1 "; _app=" $2 ";" }'`
            cat <<EOF >> $MAILDIRS/.mutt/mailcap
${_type}; a="${MAILDIRS}/tmp" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && ${_app} "\$a"/"\$f"
EOF
        done
        cat <<EOF >> $MAILDIRS/.mutt/mailcap
application/*; a="${MAILDIRS}/tmp" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && jaro preview "\$a"/"\$f"
EOF
    } # Applications.txt



	rm -f "$MAILDIRS/.mutt/notmuch"
	touch "$MAILDIRS/.mutt/notmuch"
    # when peeking and using mutt-kz use the sidebar
    is_mutt_notmuch && {

		# avoid hangs at boot for files not found
		mkdir -p $MAILDIRS/.notmuch
		touch $MAILDIRS/.notmuch/xapian

        cat <<EOF >> "$MAILDIRS/.mutt/notmuch"
set sidebar_width	 = 25
set sidebar_visible	 = no

color sidebar_new white default
color progress default magenta

bind index p sidebar-prev
bind index n sidebar-next
bind index <space> sidebar-open

macro pager S "<enter-command>toggle sidebar_visible<enter>"
macro index S "<enter-command>toggle sidebar_visible<enter>"

EOF

		use_notmuch && {
			# enable mutt-kz extra functions for notmuch integration
			cat <<EOF >> "$MAILDIRS/.mutt/notmuch"

bind index / vfolder-from-query
bind pager / vfolder-from-query

set index_format="%2C %Z %?GI?%GI& ? %[%d/%b]  %-16.16F (%4c) %?M?(%3M)& ? %s %>"
# for tags at end of index add %?g?%g?
set virtual_spoolfile = yes
virtual-mailboxes \
"  Today" "notmuch://?query=     date:1d.. and tag:inbox" \
"  Last week" "notmuch://?query= date:1w.. and tag:inbox" \
"  Last month" "notmuch://?query=date:1M.. and tag:inbox" \
"  Last year" "notmuch://?query=date:1y.. and tag:inbox" \
"  Last 3yrs" "notmuch://?query=date:3y.. and tag:inbox" \
\
"ATTACHMENTS" "notmuch://?query=attachment:* and tag:inbox" \
"  Today" "notmuch://?query=attachment:* and date:1d.. and tag:inbox" \
"  Last week" "notmuch://?query=attachment:* and date:1w.. and tag:inbox" \
"  Last month" "notmuch://?query=attachment:* and date:1M.. and tag:inbox" \
"  Last year" "notmuch://?query=attachment:* and date:1y.. and tag:inbox" \
"  Last 3yrs" "notmuch://?query=attachment:* and date:3y.. and tag:inbox"

EOF
		}
	}
    rm -f $MAILDIRS/.mutt/mboxes

    for i; do _fa+=" $i "; done
    func "exec: ${mutt_exec} -F $MUTTDIR/rc ${=muttflags} ${_fa}"

	ztmp
	_mboxes=$ztmpfile


    # this one is empty and sources files in temp when necessary
    rm -f "$MAILDIRS/.mutt/muttpass"
    touch "$MAILDIRS/.mutt/muttpass"
    if [[ "$subcommand" = "peek" ]]; then
		func "x_mutt peek"
		# when peeking don't mark unread messages as Old
		# and sort date received with no threading (latest up)
		# also set the spoolfile name to INBOX (imap's default)
		sysread -o 1 <<EOF > "$MAILDIRS/.mutt/muttpass"
set imap_pass = \`$WORKDIR/bin/jaro -a ${account} askpass\`
unset mark_old
set sort=reverse-date-received
set folder=${iproto}://${ilogin}@${imap}:${imap_port}
set spoolfile=${iproto}://${ilogin}@${imap}:${imap_port}/INBOX
EOF

		print -n "mailboxes +INBOX +priv" > $_mboxes

	else
		print -n "mailboxes +known +priv" > $_mboxes
		maildirmake "${MAILDIRS}/known"
		maildirmake "${MAILDIRS}/priv"
		# make the mailboxes according to filters and such

		for f in `cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $4 }'`; do
			# MUTT (generate mailboxes priority this parser)
			print  " \\" >> $_mboxes
			print -n " +${f} " >> $_mboxes
			# deliver() will make sure the maildir exists
			# maildirmake "${MAILDIRS}/${f}"
		done
	fi

    print " \\" >> $_mboxes
    print " +unsorted" >> $_mboxes
    maildirmake "${MAILDIRS}/unsorted"

    uniq $_mboxes > $MAILDIRS/.mutt/mboxes

	if [[ $DEBUG == 0 ]]; then
		${mutt_exec} -F $MUTTDIR/rc ${=muttflags} ${=_fa}
	else
		${mutt_exec} -D -d 2 -F $MUTTDIR/rc ${=muttflags} ${=_fa}
		func "DEBUG log in ~/.*muttdebug*"
	fi

	local res=$?
    return $res
}
