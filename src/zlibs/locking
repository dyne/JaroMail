#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2014 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


lock() {
    func "$dotlock: $1"
    ${WORKDIR}/bin/dotlock "$1"
    res=$?
    case $res in
	1) error "Cannot lock non existing file: $1"
	    return 1 ;;
	3) error "Locked file in use: $1"

	    pidcheck "$1"
	    return 3 ;;

	5) error "Lock is impossible on: $1"
	    return 5 ;;
	# success
	0) print "$$" > "$1.pid"
	    return 0 ;;

	*) error "Unknown error locking: $res"
	    return 1 ;;
    esac
}

newlock() { # lock file, create if not existing
    func "creating locked file: $1"
    touch "$1"
    chmod 600 "$1"
    lock "$1"
}

pidcheck() { # check if lock belongs to us
    if [ -r "${1}.pid" ]; then
        
	    lockpid="`cat ${1}.pid`"
	    func "pidcheck: $lockpid"
	    if [[ "$$" = "$lockpid" ]]; then
	        func "${1} lock belongs to us"
	    else
            
	        error "Unlock attempt by multiple processes on `basename $1`"
	        [[ "$FORCE" = "1" ]] || { _prun=1
		        while [ "$_prun" = "1" ]; do
                    [[ $global_quit = 1 ]] && { break }
		            for p in `ps ax | awk '{ print $1 }'`; do
			            { test "$p" = "$lockpid" } && { break }
		            done
		            if [ "$p" = "$lockpid" ]; then
			            act "Owner (${lockpid}) still running, waiting release..."
			            sleep 1; 
                        continue
		            else
			            act "Owner (${lockpid}) not running, taking over the lock"
			            rm -f "${1}.pid"; print "$$" > "${1}.pid"
			            _prun=0
		            fi
		        done
	        }
	        act "left behind by $lockpid - we ($$) will take over"
            
	    fi
        
    else # pid file doesn't exists
	    func "no pid file found for: $1"
	    func "we will take it over"
	    print "$$" > "${1}.pid"
    fi
    return 0
}

unlock() {
    func "unlock: $1"
    
    pidcheck "$1"
    [[ $? = 0 ]] || { return 1 }
    
    ${WORKDIR}/bin/dotlock -u "$1"
    [[ $? = 0 ]] || {
	    rm -f "$1.lock"
	    [[ $? = 0 ]] || { error "Unable to unlock: $1"; return 1 }
    }
    [[ -r "${1}.pid" ]] && { rm -f "${1}.pid" }
    return 0
}
unlink() { # delete a file that we are locking
    unlock "$1"
    ${=rm} "$1"
    func "$1 removed"
}
