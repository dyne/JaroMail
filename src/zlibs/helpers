#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# start without options: auto
# read or compose depending if there is an argument that is an email
# or a folder to start with

# which mutt binary to use
mutt="mutt"

# remote leading and trailing spaces in a string taken from stdin
trim() {
    sed -e 's/^[[:space:]]*//g ; s/[[:space:]]*\$//g'
}

# extract all emails found in a text from stdin
# outputs them one per line
extract_emails() {
awk '{ for (i=1;i<=NF;i++)
     if ( $i ~ /[[:alnum:]]@[[:alnum:]]/ ) {
       gsub(/<|>|,/ , "" , $i); print $i } }'
}

isemail() {
    [[ "$1" = "" ]] && {
        func "isemail() called on an empty string"
        return 1
    }
    print "$1" | \
        grep -E "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b" \
        > /dev/null
   return $?
}

ismailinglist() {
    _head=`awk '{ print $0 }
/^$/ { exit }'`
    [[ "$_head" =~ "List-Id" ]] \
        || [[ "$_head" =~ "X-BeenThere" ]] \
        || [[ "$_head" =~ "List-Post" ]] \
        || [[ "$_head" =~ "X-Mailman-Version" ]] \
        || [[ "$_head" =~ "Mailing-List" ]] \
        && return 0
    return 1
}
        
# parses stdin and converts some characters to html
escape_html() {
    sed -e '
s/\&/\&amp;/g
s/>/\&gt;/g
s/</\&lt;/g
s/"/\&quot;/g
'
}

# move an email file from a maildir to another
# keeping cur/new/tmp positioning
refile() {
    src="$1"
    dst="$2"

    [[ "$2" = "" ]] && {
        error "refile() needs 2 args: source file and destination maildir"
        return 1
    }

    [[ -r "$1" ]] || {
        error "refile origin file not existing: $1"
        return 1
    }

    # weak destination check, called should use maildircheck anyway
    [[ -d "$2"/new ]] || {
        error "refile destination not a maildir: $2"
        return 1
    }

    srcarr=(  ${=src//\// } )
    srcnum=${#srcarr}
    pos=${srcarr[$(( $srcnum - 1 ))]}
    func "mv $src ${dst}/${pos}/"
    [[ $DRYRUN = 0 ]] && mv $src ${dst}/${pos}/
}

autostart() {    
    # no argument passed. open first folder with new mail
    [[ "$1" = "" ]] && {
        
        [[ -r $MUTTDIR/rc ]] || {
            error "Jaro Mail is not yet configured."
            error "To configure, edit the files in $MAILDIRS/Accounts"
            error "Then run 'jaro update' at least once."
            return 1
        }
        
        ${=mutt} -F $MUTTDIR/rc ${=muttflags} -Z
        return $?
    }

    # argument passed: determine if an email
    isemail "$1"
    [[ $? = 0 ]] && {
        notice "Composing message to: ${@}"
        # its an email, TODO see if we have it in our addressbook
        ${=mutt} -F $MUTTDIR/rc ${=muttflags} ${=@}
        return 0
    }

    # or a directory of file
    [[ -r "$1" ]] && {
        # is it a maildir? then open
        maildircheck ${1}
        [[ $? = 0 ]] && {
            ${=mutt} -F $MUTTDIR/rc ${=muttflags} -f ${1}
            return 0
        }
        # is it a regular file? then attach it
        [[ -f "$1" ]] && {
            ${=mutt} -F $MUTTDIR/rc ${=muttflags} -a ${=@}
            return 0
        }
    }

    # or the name of a folder in Jaro Mail
    maildircheck "$MAILDIRS/$1"
    [[ $? = 0 ]] && {
        notice "Opening folder ${1}"
        ${=mutt} -F $MUTTDIR/rc ${=muttflags} -f "$MAILDIRS/${1}"
        return 0
    }

    return 1
}


# short utility to print only mail headers
hdr() {
    { test -r "$1" } || {
        error "hdr() called on non existing file: $1"
        return 1 }
    awk '{ print $0 }
/^$/ { exit }' "$1"
}

# short utility to print only mail body
body() {
    { test -r "$1" } || {
    error "body() called on non existing file: $1"
    return 1 }
    awk '
BEGIN { head=1 }
/^$/ { head=0 }
{ if(head==0)
    print $0
  else
    next }' "$1"
}


#########
## Editor
# this part guesses what is the best editor already present on the system
# of course we have a preference for AutOrg, the editor from our suite
# however the default is nano if nothing else is choosen.
jarovim() {
    vim -c 'set fo=tcrq' -c 'set tw=72' \
    -c 'map <C-j> {gq}' -c 'imap <C-j> <esc>{gq}i' \
        "${@}"
    return $?
}

edit_file() {
    { test ${EDITOR} } && { _editor="${EDITOR}" }
    { test ${JARO_EDITOR} } && { _editor="$JARO_EDITOR" }
    { test "$_editor" = "" } && { _editor=vim }
    case $_editor in
    # refine settings for email
    vi|vim) jarovim "${PARAM}"; return $? ;;
    emacs) emacsclient -a emacs "${PARAM}"; return $? ;;
    *) ${=_editor} "${PARAM}"; return $? ;;
    esac

    # if we are here we need to guess
    case $OS in
    MAC) open -t ${=PARAM} ;;
    GNU)
        ps ax|grep '[e]macs' > /dev/null
        if [ $? = 0 ]; then
        emacsclient -a ${=PARAM}
        elif command -v vim > /dev/null; then
        jarovim ${=PARAM}
        elif command -v nano > /dev/null; then
        nano -m -S -Q ">" -I -E -D -T 4 -U -W -c -i -k -r 72 ${=PARAM}
        else
        error "No editor found, please configure the JARO_EDITOR environment variable."
        fi
        ;;
    esac
    return $?
}

#####################
## Open a mail folder
open_folder() {
    notice "Opening folder ${1}"
    { maildircheck ${MAILDIRS}/${1} } && {
    ${=mutt} -F $MUTTDIR/rc ${=muttflags} -f "$MAILDIRS/${1}"
    return $? }
    return 1
}

##############
## Open a File
preview_file() {
    case $OS in
    GNU)
        xdg-open "${PARAM}" &
        ;;
    MAC)
        open -g "${PARAM}"
        ;;
    esac
}


#########################
## check if we are online
is_online() {
    func "Test if we are online"
    { test "$FORCE" = "1" } && {
    act "Internet check skipped (--force in use)"
    return 0
    }
    _res=1
    _host=${1:-8.8.8.8}
    _port=${2:-NONE}

    _mode=inet # or host
    { test "$_port" = "NONE" } || { _mode=host }

    case $_mode in
    inet)
        func "trying to ping ${_host}"
        ping -c1 -n ${_host} 2>&1 > /dev/null
        { test $? = 0 } || {
        error "Internet seems unreachable"
        act "Network connection is checked with a ping to 8.8.8.8"
        act "if your network doesn't allows it to pass, use -f to force."
        error "Operation aborted."
        exit 1
        }
        act "Internet seems to be reachable"
        ;;
    host)
        func "trying to connect ${_host} port ${_port}"
        nc -w 16 -z ${_host} ${_port} > /dev/null
        { test $? = 0 } || {
        error "Host unreachable: $_host"
        act "Network connection is checked with 16s timeout"
        act "if you want to bypass this check, use -f to force."
        error "Operation aborted."
        return 1
        }
        act "Host $_host responds on port $_port"
        ;;
    esac
    return 0
}


# opens and closes a ramdisk for temporary files
# users can do this explicitly between session to speed up operations
ramdisk() {
    case $OS in
    GNU)
        # TODO
        # not so urgent, since usually /dev/shm is mounted and writable
        ;;
    MAC)
        case ${PARAM[1]} in
        open)
            mount | grep 'JaroTmp' > /dev/null
            { test $? = 0 } && {
            error "A Jaro Mail ramdisk is already open"
            return 1 }
            { test -z ${PARAM[2]} } && { size=10 } || { size=${PARAM[2]} }
            act "Creating ramdisk of ${size}MB"

            # 2048 is a megabyte here
            devsize=$((1024*2*$size))
            devname=`hdid -nomount ram://${devsize}`
            act "Mounting ramdisk on $devname"
            diskutil eraseVolume HFS+ JaroTmp `basename $devname` > /dev/null
            { test $? != 0 } && {
            error "Error initializing ramdisk"
            hdiutil detach `basename $devname`
            return 1 }
            notice "Operation successful, ramdisk ready on /Volume/JaroTmp"
            TMPRAM=1
            ;;
        close)
            devname=`mount | awk '/JaroTmp/ {print $1}'`
            { test "$devname" = "" } && {
            error "No ramdisk seems to be open"
            return 1 }
            act "Unmounting ramdisk: $devname"
            diskutil unmount /Volumes/JaroTmp > /dev/null
            hdiutil detach `basename $devname` > /dev/null
            notice "Ramdisk succesfully detached"
            TMPRAM=0
            ;;
        esac
        ;;
    esac
}

human_size() {
    { test $1 -gt 0 } || {
    error "human_size() called with zero argument"
    return 1 }
    # megabytes
    { test $1 -gt 1048576 } && {
    print -n "$(( $1 / 1024 / 1024 )) MB"
    return 0}
    # kilobytes
    { test $1 -gt 1024 } && {
    print -n "$(( $1 / 1024 )) KB"
    return 0}
    # bytes
    print -n "$1 Bytes"
    return 0
}

######
# CERT
# downloads and/or installs certificates
cert() {

    act "Downloading all known certificates (needs Internet connectivity)"

#	gmail)
    cc=Equifax_Secure_Certificate_Authority
    if ! [ -r $MAILDIRS/certs/${cc}.pem ]; then

    curl -o $MAILDIRS/certs/${cc}.pem \
        "https://www.geotrust.com/resources/root_certificates/certificates/${cc}.cer"
    openssl x509 -in \
        $MAILDIRS/certs/${cc}.pem -fingerprint \
        -subject -issuer -serial -hash -noout
    fi
    notice "Google CA succesfully installed"

#	dyne|autistici|freaknet)
    cc=Autistici_Certificate_Authority
    if ! [ -r $MAILDIRS/certs/${cc}.pem ]; then
    curl -o $MAILDIRS/certs/${cc}.pem \
        "http://ca.autistici.org/ca.pem"
    openssl x509 -in \
        $MAILDIRS/certs/${cc}.pem \
        -fingerprint -subject -issuer -serial -hash -noout
    fi
    notice "Aut/Inv CA succesfully installed"

#	riseup)
    cc=RiseupCA
    if ! [ -r $MAILDIRS/certs/${cc}.pem ]; then
    curl -o $MAILDIRS/certs/${cc}.pem "https://help.riseup.net/assets/43052/RiseupCA.pem"
    openssl x509 -in \
        $MAILDIRS/certs/${cc}.pem \
        -fingerprint -subject -issuer -serial -hash -noout
    fi
    notice "Riseup CA succesfully installed"

    act "refreshing certificates"
    c_rehash $MAILDIRS/certs > /dev/null
    if [ $? != 0 ]; then
    error "Error refreshing certificates in $MAILDIRS/certs"
    c_rehash $MAILDIRS/certs
    fi
    notice "Done importing most common certificates."
    return 0
}

######################
