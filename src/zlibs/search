#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#######################
## Search into maildirs
# using notmuch


# internal use
nm() {
    func "notmuch $@"
    [[ -r "$MAILDIRS"/cache/notmuch/rc ]] || nm_setup
    notmuch --config="$MAILDIRS"/cache/notmuch/rc ${@}
    _res=$?
    [[ $_res = 0 ]] || {
        error "Notmuch error on command: ${@}"
        func "Returning status to caller: $_res"
    }
    return $_res
}

nm_setup() {
    nm_dir="$MAILDIRS"/cache/notmuch
    mkdir -p $nm_dir

    # setup the default tags for all new messages
    deftags="$1"

    act "notmuch setup $deftags"
    
    # read if there are other email aliases configured
    [[ -r "$MAILDIRS"/Aliases.txt ]] && {
        other_email="other_email"
        _aliases=`cat "$MAILDIRS"/Aliases.txt`
        _sep=\=
        for i in ${(f)_aliases}; do
            other_email+="${_sep}${i}"
            _sep=";"
        done
    }

    rm -f "$nm_dir"/rc
    cat <<EOF > "$nm_dir"/rc
[database]
path=$MAILDIRS

[new]
tags=$deftags
ignore=tmp;cache;logs;outbox;incoming;zz.social;zz.bounces;zz.blacklist;zz.spam;Accounts;Groups;.mutt;webnomad;Aliases.txt;Filters;Identity.txt;Keyring;Manual.pdf;Mutt.txt;whitelist.abook;blacklist.abook;Applications.txt;Filters.sieve;Filters.txt

[maildir]
synchronize_flags=true
EOF
    [[ "$name" = "" ]] || {
        cat <<EOF >> "$nm_dir"/rc

[user]
name=$name
primary_email=$email
$other_email
EOF
    }
}

nm_index() {
    # init the environment
    read_account
    notice "Indexing all mail archive"
    act "please wait, this may take a while..."
    nm_setup
    nm new
    nm tag +inbox +priv -unsorted folder:known
    nm tag +inbox +priv -unsorted folder:sent
    nm tag -inbox +priv -unsorted folder:priv
    nm tag -inbox -priv +unsorted folder:unsorted
    act "compressing database"
    nm compact
    notice "Indexing completed"
}


nm_search() {
    func "notmuch --config=${nm_dir}/rc search --output=files ${=PARAM}"
    
    # launch the search with notmuch
    search_results=`nm search --output=files ${=PARAM}`
    [[ $? = 0 ]] || {
        error "notmuch search failed with an error"
        return 1
    }
    act "`print ${search_results} | wc -l` emails found"
    for i in ${(f)search_results}; do
        print - "$i"
    done
}


# run a search with notmuch and show results with alot
alot_search() {
    read_account
    nm_setup
    
    notice "Searching emails for: $=PARAM"

    # read if there are other email aliases configured
    [[ -r "$MAILDIRS"/Aliases.txt ]] && {
        other_email="aliases"
        _aliases=`cat "$MAILDIRS"/Aliases.txt`
        _sep=" = "
        for i in ${(f)_aliases}; do
            other_email+="${_sep}${i}"
            _sep=","
        done
    }

    # setup alot to show results
    mkdir -p "$MAILDIRS"/cache/alot
    cat <<EOF > "$MAILDIRS"/cache/alot/rc

editor_cmd = jaro edit
edit_headers_whitelist = From,To,Cc,Subject
displayed_headers = From,To,Cc,Bcc,Subject,User-Agent
auto_remove_unread = True
honor_followup_to = True
hooksfile = $MAILDIRS/cache/alot/hooks.py
initial_command = search tag:inbox
prefer_plaintext = True
tabwidth = 4
user_agent = Jaro Mail <http://jaromail.dyne.org>

[bindings]
  i = search tag:inbox
  p = search tag:priv
  u = search tag:unsorted
  / = prompt 'search '
  l = prompt 'search '
  backspace = bclose

[accounts]
    [[$account]]
        realname = $name
        address = $email
        sendmail_command = jaro queue
        sent_box = maildir:///$MAILDIRS/sent
        $other_email
        [[[abook]]]
           type = shellcommand
           command = jaro -q search addr 
           regexp = (?P<name>.+)\s*<(?P<email>.*.+?@.+?)>

[tags]
  [[inbox]]
    translated = ★
  [[priv]]
    translated = ⚡
  [[attachment]]
    translated = ⚓
  [[unsorted]]
    translated = ?
  [[flagged]]
    translated = ⚑
    normal = '','','light red','','light red',''
    focus = '','','light red','','light red',''
  [[unread]]
    translated = ☉
  [[replied]]
    translated = ⏎
  [[encrypted]]
    translated = ⚷
  [[signed]]
    translated = ✍
  [[filters]]
    translated = ⚙
  [[mailinglist]]
    translated = ☰
EOF

    alot -c "$MAILDIRS"/cache/alot/rc -n "$MAILDIRS"/cache/notmuch/rc \
        search ${=PARAM}
    return $?
}

search() {
    
    [[ "$PARAM" = "" ]] && {
	    error "No search terms specified."
	    return 1
    }
    
    typeset -al term
	typeset -alU results
    
    for p in ${PARAM}; do
        func "param ${p} is a search term"
        term+=(${p})
    done
    
    [[ "$PARAM" =~ "addr" ]] && {
        # if addr specified search into the addressbook
	    notice "Searching addressbook for: ${PARAM//addr/}"
	    res=""
	    for t in ${term}; do
            [[ "$t" =~ "addr" ]] && continue
            # res+=`search_addressbook ${t}`
	        search_addressbook ${t} | awk '
/^$/ { next }
{ for(c=2;c<=NF;c++) printf "%s ", $c
  print "<" $1 ">" }'
	    done
        return 0
    }
    
    # run search across emails
    alot_search ${=PARAM}
}

backup() {
    id=$datestamp.$RANDOM
    mairixrc=$TMPDIR/backup.rc.$id
    mairixdb=$TMPDIR/backup.db.$id
    typeset -al expr
    typeset -al fold

    src=""; dst=""
    basedir=$MAILDIRS
    # check if the name of a maildir is among params
    # we need at least 2 maildirs, the second is the destination
    for p in ${PARAM}; do
	    c=$(( $c + 1 ))

	    if [ $c = ${#PARAM} ]; then
	        # last one is always the destination
	        func "destination is ${p}"
	        fold+=(${p})

	    elif [ -r "${p}" ]; then

	        { maildircheck ${p} } && {
		        func "param ${p} is a maildir"
		        fold+=(${p})
		        { test ${#fold} = 1 } && {
		            # base path is the dir of the first folder
		            pushd `dirname ${p}`
		            basedir=`pwd`
		            popd }
	        }

	    elif [ -r "${MAILDIRS}/${p}" ]; then

	        { maildircheck ${MAILDIRS}/${p} } && {
		        func "param ${p} is a jaro maildir"
		        fold+=(${MAILDIRS}/${p})
	        }

	    else # not a folder, add it to expressions array
	        func "param ${p} is an expression"
	        expr+=(${p})
	    fi
    done

    { test ${#fold} -lt 2 } && {
	    error "Not enough folders specified for backup: minimum is 2"
	    act "When specifying more than 2, the last one is the destination"
	    return 1
    }

    dst=${fold[${#fold}]}
    { test -r "$dst" } || { maildirmake "${dst}" }

    { test ${#expr} = 0 } && {
	    error "No expression set for backup, please indicate what you want to backup"
	    act "For example: d:10y-2y (all mails older than 1 year up to 10 years ago)"
	    act "Or a simple search string, all expressions can be verified using search."
	    return 1
    }

    # forge the folder string for mairix conf
    folders=""
    for f in ${=fold}; do
	    { test $f = $dst } || {
	        folders="$folders`basename $f`:" }
    done

    notice "Backup of all mails in '$folders' matching expression '$expr'"

    act "Indexing folders"
    cat <<EOF > ${mairixrc}
base=$basedir
database=$mairixdb
maildir=${folders}
mformat=maildir
EOF
    mairix -F -f ${mairixrc} 2> /dev/null
    tempdst="bck.`basename $dst`"
    notice "Backup of $dst"
    rm -f ${mairixrc}; cat <<EOF > ${mairixrc}
base=$basedir
database=$mairixdb
maildir=${folders}
mfolder=$tempdst
mformat=maildir
EOF
    mairix -F -f ${mairixrc} -t -M ${expr}
    { test -r $basedir/$tempdst } && { 
        merge $basedir/$tempdst $dst
        notice "Destination folder size is `du -hs $dst | awk '{print $1}'`"
    }

    ${=rm} ${mairixrc}
    ${=rm} ${mairixdb}

    act "Backup completed to destination: $dst"
}
