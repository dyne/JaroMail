#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

###################
# Filters workflow:
#
#  1. Check if From in blacklist   -> zz.blacklist
#  2. Check if /Sender.*bounce/    -> zz.bounces
#  3. Check if From Filters match  -> own.setup
#  4. Check if To   Filters match  -> own.setup
#  5. Check if From in whitelist   -> known
#  6. Check if /X-Spam-Flag.*YES/  -> Spam
#  7. Check if To own address      -> priv
#  8. All the rest                 -> unsorted
#

# load zsh filter cache arrays
test -r  "$MAILDIRS/cache/filters" && {
    source "$MAILDIRS/cache/filters"
}

init_inbox() {
    fn init_inbox
    req=(MAILDIRS)
    ckreq || return 1

    # make sure maildirs where to put mails exist
    ${=mkdir} "$MAILDIRS"
    maildirmake "$MAILDIRS/incoming"
    maildirmake "$MAILDIRS/known"
    maildirmake "$MAILDIRS/sent"
    maildirmake "$MAILDIRS/priv"
    maildirmake "$MAILDIRS/postponed"
    maildirmake "$MAILDIRS/drafts"
    maildirmake "$MAILDIRS/unsorted"
    maildirmake "$MAILDIRS/remember"
    maildirmake "$MAILDIRS/outbox"

    [[ -f "$PASSWORD_STORE_DIR/.gpg-id" ]] || {
		[[ -r $HOME/.gnupg/gpg.conf ]] && {
            GPGID=${$(awk '/default-key/ { print $2 }' $HOME/.gnupg/gpg.conf)}
			pass init ${GPGID}
		}
    }

    ${=mkdir} "$MAILDIRS/cache"
    ${=mkdir} "$MAILDIRS/logs"
    ${=mkdir} "$MAILDIRS/tmp"
    ${=mkdir} "$ACCOUNTS"

    test -r "$ACCOUNTS/default.txt" ||
		cp -a "$WORKDIR"/Accounts/* "$ACCOUNTS/"

    { test -r "$MAILDIRS"/Manual.pdf } || {
    cp "$WORKDIR"/jaromail-manual.pdf "$MAILDIRS"/Manual.pdf }

    { test -r "$MAILDIRS"/Filters.txt } || {
    cp "$WORKDIR"/Filters.txt "$MAILDIRS"/Filters.txt }

    { test -r "$MAILDIRS"/Aliases.txt } || {
    cp "$WORKDIR"/Aliases.txt "$MAILDIRS"/Aliases.txt }

    { test -r "$MAILDIRS"/Applications.txt } || {
    cp "$WORKDIR"/Applications.txt "$MAILDIRS"/Applications.txt }

    # make sure the permissions are private
    chmod 700 "$MAILDIRS"

    return 0
}

# reads all configurations and creates a cache of what is read
# the cache consists of array and maps declarations for zsh
update_filters() {
    fn update_filters
    req=(MAILDIRS)
    freq=($MAILDIRS/Filters.txt)
    ckreq || return 1

    notice "Updating filters..."

    local ff="$MAILDIRS/cache/filters"
    ${=mkdir} "$MAILDIRS/cache"

    [[ -r "$ff" ]] && { rm -f "$ff" }
    newlock "$ff"
    cat <<EOF >> "$ff"
# automatically generated by jaromail
typeset -Al  filter_from
typeset -alU filter_own
typeset -Al  filter_to
filter_from=()
filter_own=()
filter_to=()

EOF

	local ffilters

    ffilters=`awk '
    /^#/ {next}
    /^./ { print $1 ";" $2 ";" $3 ";" $4 }' "$MAILDIRS/Filters.txt"`

    #
    func "insert filter rules in the cache"

    for f in ${(f)ffilters}; do
        header="${f[(ws:;:)1]}"
        regexp="${f[(ws:;:)2]}"
        action="${f[(ws:;:)3]}"
        destination="${f[(ws:;:)4]}"
        case $header in
            to)
                cat <<EOF >> "$ff"
filter_to+=("${regexp}" "${destination}")
EOF
                func "from: <${regexp}> -> ${destination}"
                ;;
            from)
                cat <<EOF >> "$ff"
filter_from+=("${regexp}" "${destination}")
EOF
                func "to: <${regexp}> -> ${destination}"
                ;;

            *)
                error "invalid filter: $f"
                ;;
        esac
    done

    # # create the notmuch database if not present
    # [[ -r "$MAILDIRS"/cache/notmuch/rc ]] || {
    #     notice "Indexing emails in the search database"
    #     nm setup
    #     nm new
    # }

    #
    func "compile the list of own addresses and aliases"

    for i in `awk '
/^#/ { next }
/^$/ { next }
/^email/ { print $2 }' \
 "$MAILDIRS"/Accounts/*`; do
        cat <<EOF >> "$ff"
filter_own+=($i)
EOF
    done
    { test -r $MAILDIRS/Aliases.txt } && {
        for i in `awk '
/^#/ { next }
/^$/ { next }
{ print $1 }' "$MAILDIRS/Aliases.txt"`; do
            cat <<EOF >> "$ff"
filter_own+=($i)
EOF
        done
    }

	func "insert addressbook whitelist in the cache"
	ffilters=`jaro addr -l whitelist | getemail`
	for f in ${(f)ffilters}; do
		cat <<EOF >> "$ff"
filter_from+=("${f}" "known")
EOF
	done

    #
    func "unlocking and compiling the cache"

    unlock "$ff"
    zcompile "$ff"
    func "recursive reload"
    source "$WORKDIR/zlibs/filters"
    return 0
}


filter_maildir() {
    fn filter_maildir
    req=(MAILDIRS)
    ckreq || return 1

    # Makes glob matching case insensitive
    unsetopt CASE_MATCH

    # default maildir to filter is incoming
    mdinput="${1:-incoming}"

    # for safety we bail out in case the final fallback
    # maildir is not existing. unsorted should always
    # be there.
    maildircheck "$MAILDIRS/unsorted"
    [[ $? = 0 ]] || {
        error "Invalid fallback maildir destination, operation aborted."
        func "Returning error to caller."
        return 1
    }

    # loads up the filter cache (zsh compiled arrays)
    [[ -r "$MAILDIRS/cache/filters" ]] && {
        source $MAILDIRS/cache/filters
        ownfilters=1
    }

    maildircheck "$MAILDIRS/$mdinput"
    [[ $? = 0 ]] || {
        error "Invalid maildir to filter: $mdinput"
        return 1
    }

    mails=`${=find} "$MAILDIRS/$mdinput" -maxdepth 2 -type f`
    numm=`print $mails | wc -l`

    [[ $numm = 0 ]] && {
        error "Nothing to filter inside maildir $mdinput"
        return 1
    }

    notice "Filtering maildir: $mdinput ($numm mails)"
    c=0

    for m in ${(f)mails}; do

        # clean interrupt
        [[ $global_quit = 1 ]] && {
            error "User break requested, interrupting operation"
            break
        }

        match=0
        c=$(($c + 1))

        # check if its an empty file
        _fsize=`zstat +size "$m"`
        [[ $_fsize = 0 ]] && {
            act "$c\t/ $numm\t(empty)"
            rm "$m"
            continue
        }

        # parse if its a mailinglist
        _ml=0
        hdr "$m" | ismailinglist
        [[ $? = 0 ]] && _ml=1

        list="blacklist"
        hdr "$m" | sender_isknown
        [[ $? = 0 ]] && {
            [[ "$mdinput" = "zz.blacklist" ]] && {
                act "$c\t/ $numm"
                continue
            }

            act "$c\t/ $numm\t-> zz.blacklist"

            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver zz.blacklist
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }

        hdr "$m" | awk '/Sender.*mailman-bounce/ { exit 1 }'
        [[ $? = 0 ]] || {
            [[ "$mdinput" = "zz.bounces" ]] && {
                act "$c\t/ $numm"
                continue
            }
            act "$c\t/ $numm\t-> zz.bounces"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver zz.bounces
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }

        [[ "$ownfilters" = "1" ]] && {

            func "processing through own filters"

            # run all filter regexps on the from: field
            _dest=""
            e_addr=()
			local femail=""
			if command -v maddr > /dev/null; then
				femail=`maddr -h from "$m" | getemail`
			else
				hdr "$m" | e_parse From
                femail="${(k)e_addr}" # e_parse From hit is always one
			fi
            for exp in ${(k)filter_from}; do
				local found=0
				if [[ "$femail" == "$exp" ]]; then
					found=1
				elif [[ "$femail" =~ "$exp" ]]; then
					found=1	# fuzzy match on a string (PCRE)
				fi
                if [[ "$found" == "1" ]]; then
                    # retrieve the filter destination maildir
                    _dest="${filter_from[$exp]}"
                    # if destination maildir is same as input, skip
                    [[ "$_dest" == "$mdinput" ]] && {
                        act "$c\t/ $numm"
                        match=1
                        break
                    }
                    act "$c\t/ $numm\t-> $_dest\t(from $femail)"
                    # tag mailinglists
                    [[ $DRYRUN = 1 ]] || {
						printfile "$m" | deliver "$_dest"
                    }
                    if [[ $? = 0 ]]; then
                        match=1
                        rm "$m"
                        break
                    else
                        error "Error filtering to maildir $_dest"
                        error "File: $m"
                        continue
                    fi
                fi
            done
            [[ "$match" = "1" ]] && {
                func "matched filter from: field"
                continue
            }

            _dest=""
            # recompile the array of destination addresses
            e_addr=()
            hdr "$m" | e_parse To
            hdr "$m" | e_parse Cc
            # run all filter regexps on the to: and cc: fields
            [[ $? = 0 ]] && {
                for ft in ${(k)e_addr}; do
                    for exp in ${(k)filter_to}; do
						local found=0
						if [[ "$ft" == "$exp" ]]; then
							found=1
						elif [[ "$ft" =~ "$exp" ]]; then
							found=1	# fuzzy match on a string (PCRE)
						fi
                        # fuzzy match on a string (PCRE)
                        if [[ "$found" == "1" ]]; then

                            # retrieve the filter destination maildir
                            _dest="${filter_to[$exp]}"

                            # if destination maildir is same as input, skip
                            [[ "$_dest" == "$mdinput" ]] && {
                                act "$c\t/ $numm"
                                match=1
                                break
                            }

                            act "$c\t/ $numm\t-> $_dest\t(to $ft)"
                            # tag mailinglists
                            [[ $DRYRUN = 1 ]] || {
                                printfile "$m" | deliver "$_dest"
                            }

                            if [[ $? = 0 ]]; then
                                match=1
                                rm "$m"
                                break
                            else
                                error "Error filtering to maildir $_dest"
                                error "File: $m"
                                continue
                            fi
                        fi
                    done
                    [[ "$match" = "1" ]] && { break }
                done
            }

            [[ "$match" = "1" ]] && {
                func "matched filter to:/cc: fields"
                continue
            }

        } # own filters

        hdr "$m" | awk '/X-Spam-Flag.*YES/ { exit 1 }'
        { test $? = 0 } || {
            [[ "$mdinput" = "Spam" ]] && {
                act "$c\t/ $numm"
                continue
            }
            act "$c\t/ $numm\t-> Spam"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver Spam
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }

        # parse own email and aliases
        match=0
        for f in ${(k)e_addr}; do
            # check if destination address is in filter_own array
            [[ ${filter_own[(r)$f]} == ${f} ]] && {
                [[ "$mdinput" = "priv" ]] && {
                    act "$c\t/ $numm"
                    match=1
                    break
                }
                act "$c\t/ $numm\t-> priv"
                [[ $DRYRUN = 1 ]] || {
                    printfile "$m" | deliver priv "+priv"
                    [[ $? = 0 ]] && {
                        rm "$m";
                        match=1
                        break
                    }
                }
            }
        done
        [[ $match = 1 ]] && continue

        # if here then file to unsorted
        if [ "$mdinput" = "unsorted" ]; then
            act "$c\t/ $numm"
        else
            act "$c\t/ $numm\t-> unsorted"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver unsorted "+unsorted"
                [[ $? = 0 ]] && { rm "$m" }
            }
        fi

    done

    return 0
}


# sieve_filter() gets an array of patterns to match and builds a long rule
# for which if they match the conditional directive they all go in one folder
# $1 = conditional directive
# $2 = folder to fileinto
# sieve_filter_array: array of entries
typeset -alU sieve_filter_array
sieve_filter() {
    condition="$1"
    fileinto="$2"

    cat <<EOF >> "$MAILDIRS/Filters.sieve"

# $fileinto
$condition [
EOF
    c=${#sieve_filter_array}
    for i in $sieve_filter_array; do
    print -n "\"$i\"" >> "$MAILDIRS/Filters.sieve"
    c=$(( $c - 1 ))
    { test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
    print >> "$MAILDIRS/Filters.sieve"
    done

    cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto :create "$fileinto"; stop; }

EOF
    return 0
}

typeset -A sieve_filter_map
# sieve_complex_filter gets a map of patterns as an argument and builds a
# long rule for which any key matching it gets delivered to its value folder
# $1 = conditional directive
# sieve_filter_map = map of patterns, key is match and value is destination
# assign with set -A sieve_filter_map yourmap
sieve_complex_filter() {
    [[ ${#sieve_filter_map} == 0 ]] && { return 1 }
    condition="$1"
    func "Sieve complex filter entries: ${#sieve_filter_map}"

    for fil in ${(k)sieve_filter_map}; do
        print "$condition \"${fil}\" { fileinto :create \"${sieve_filter_map[$fil]}\"; stop; }" \
            >> "$MAILDIRS/Filters.sieve"
    done

    return 0
}

update_sieve() {

    #######
    # SIEVE
    act "generating sieve filter rules"
    id=`datestamp`.$RANDOM
    newlock "$MAILDIRS/Filters.sieve"
    rm -f "$MAILDIRS/Filters.sieve"
    touch "$MAILDIRS/Filters.sieve"
    chmod 600 "$MAILDIRS/Filters.sieve"
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# mailbox supports fileinto :create
require ["fileinto","mailbox","variables"];

EOF

    # blacklist
    [[ -r "$MAILDIRS"/blacklist.abook ]] && {
        sieve_filter_array=()

        for i in `awk -F'=' '
/^email/ { print $2 }
' "$MAILDIRS"/blacklist.abook`; do
            sieve_filter_array+=("$i")
        done

        { test "${#sieve_filter_array}" = "0" } || {
            sieve_filter \
                'if header :contains "From"' \
                zz.blacklist
        }
    }

    # bounces
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# bounces
if header :contains "Sender" "mailman-bounce" {
    fileinto :create "zz.bounces";
    stop;
}

#############
# own filters

EOF

    set -A sieve_filter_map ${(kv)filter_to}
    sieve_complex_filter 'if header :contains [ "To","Cc" ] '

    set -A sieve_filter_map ${(kv)filter_from}
    sieve_complex_filter 'if header :contains [ "From","Sender" ] '




    ##############################################################
    # if the sender is known (whitelist) then put mail in
    # high priority 'known' maildir or INBOX (sieve)

    act "compiling whitelist rules from addressbook"
    func "generating whitelist for sieve filters"

    [[ -r "$MAILDIRS"/whitelist.abook ]] && {
        sieve_filter_array=()
        for i in `awk -F'=' '
/^email/ { print $2 }
' "$MAILDIRS"/whitelist.abook`; do
            sieve_filter_array+=("$i")
        done
        sieve_filter \
            'if header :contains [ "From","Sender" ]' \
            INBOX
    }

        cat <<EOF >> "$MAILDIRS/Filters.sieve"
# spam
if header :is "X-Spam-Flag" "YES" {
    fileinto :create "Spam"; stop;
}

EOF

    # own addresses and aliases
    sieve_filter_array=($filter_own)
    sieve_filter \
    'if header :contains [ "To","Cc" ] ' \
    priv

    # unsorted
    cat <<EOF >> "$MAILDIRS/Filters.sieve"

fileinto :create "unsorted";

EOF

    unlock "$MAILDIRS/Filters.sieve"

    return 0
} # end of update()
