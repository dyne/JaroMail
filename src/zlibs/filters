#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2015 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

###################
# Filters workflow:
#
#  1. Check if From in blacklist   -> zz.blacklist
#  2. Check if /Sender.*bounce/    -> zz.bounces
#  3. Check if From Filters match  -> own.setup
#  4. Check if To   Filters match  -> own.setup
#  5. Check if From in whitelist   -> known
#  6. Check if /X-Spam-Flag.*YES/  -> zz.spam
#  7. Check if To own address      -> priv
#  8. All the rest                 -> unsorted
#

# load zsh filter cache arrays
{ test -r  "$MAILDIRS/cache/filters" } && {
    source "$MAILDIRS/cache/filters" }

init_inbox() {
    # make sure maildirs where to put mails exist
    ${=mkdir} "$MAILDIRS"
    maildirmake "$MAILDIRS/incoming"
    maildirmake "$MAILDIRS/known"
    maildirmake "$MAILDIRS/sent"
    maildirmake "$MAILDIRS/priv"
    maildirmake "$MAILDIRS/postponed"
    maildirmake "$MAILDIRS/unsorted"
    maildirmake "$MAILDIRS/unsorted.ml"
    maildirmake "$MAILDIRS/remember"
    maildirmake "$MAILDIRS/outbox"

    ${=mkdir} "$MAILDIRS/cache"
    ${=mkdir} "$MAILDIRS/logs"
    ${=mkdir} "$MAILDIRS/tmp"

    { test -d "$MAILDIRS/Accounts" } || {
    ${=mkdir} "$MAILDIRS/Accounts"
    cp "$WORKDIR"/Accounts/* "$MAILDIRS/Accounts/" }

    { test -r "$MAILDIRS"/Manual.pdf } || {
    cp "$WORKDIR"/jaromail-manual.pdf "$MAILDIRS"/Manual.pdf }

    { test -r "$MAILDIRS"/Identity.txt } || {
    cp "$WORKDIR"/Identity.txt "$MAILDIRS"/Identity.txt }

    { test -r "$MAILDIRS"/Filters.txt } || {
    cp "$WORKDIR"/Filters.txt "$MAILDIRS"/Filters.txt }

    { test -r "$MAILDIRS"/Aliases.txt } || {
    cp "$WORKDIR"/Aliases.txt "$MAILDIRS"/Aliases.txt }

    { test -r "$MAILDIRS"/Applications.txt } || {
    cp "$WORKDIR"/Applications.txt "$MAILDIRS"/Applications.txt }

    return 0
}

# reads all configurations and creates a cache of what is read
# the cache consists of array and maps declarations for zsh
update_filters() {
    [[ -r "$MAILDIRS/Filters.txt" ]] || {
        error "Filters not found in $MAILDIRS/Filters.txt"
        return 1
    }
    
    notice "Updating filters..."

    ff="$MAILDIRS/cache/filters"
    ${=mkdir} "$MAILDIRS/cache"

    [[ -r "$ff" ]] && { rm -f "$ff" }
    newlock "$ff"
    sysread -o 1 <<EOF >> "$ff"
# automatically generated by jaromail
typeset -Al  filter_from
typeset -alU filter_own
typeset -Al  filter_to
filter_from=()
filter_own=()
filter_to=()

EOF
    ffilters=`awk '
    /^#/ {next}
    /^./ { print $1 ";" $2 ";" $3 ";" $4 }' "$MAILDIRS/Filters.txt"`

    # insert filter rules in the cache
    for f in ${(f)ffilters}; do
        header="${f[(ws:;:)1]}"
        regexp="${f[(ws:;:)2]}"
        action="${f[(ws:;:)3]}"
        destination="${f[(ws:;:)4]}"
        case $header in
            to)
                sysread -o 1 <<EOF >> "$ff"
filter_to+=("${regexp}" "${destination}")
EOF
                func "from: <${regexp}> -> ${destination}"
                maildirmake $MAILDIRS/$destination
                ;;
            from)
                sysread -o 1 <<EOF >> "$ff"
filter_from+=("${regexp}" "${destination}")
EOF
                func "to: <${regexp}> -> ${destination}"
                maildirmake $MAILDIRS/$destination
                ;;

            *)
                error "invalid filter: $f"
                ;;
        esac
    done

    # # create the notmuch database if not present
    # [[ -r "$MAILDIRS"/cache/notmuch/rc ]] || {
    #     notice "Indexing emails in the search database"
    #     nm setup
    #     nm new
    # }

    # compile the list of own addresses and aliases
    for i in `awk '
/^#/ { next }
/^$/ { next }
/^email/ { print $2 }' \
 "$MAILDIRS"/Accounts/*`; do
        sysread -o 1 <<EOF >> "$ff"
filter_own+=($i)
EOF
    done
    { test -r $MAILDIRS/Aliases.txt } && {
        for i in `awk '
/^#/ { next }
/^$/ { next }
{ print $1 }' "$MAILDIRS/Aliases.txt"`; do
            sysread -o 1 <<EOF >> "$ff"
filter_own+=($i)
EOF
        done
    }

    unlock "$ff"
    zcompile "$ff"
    # recursive reload
    source "$WORKDIR/zlibs/filters"
    return 0
}


filter_maildir() {
    # Makes glob matching case insensitive
    unsetopt CASE_MATCH

    mdinput="$1"

    # for safety we bail out in case the final fallback
    # maildir is not existing. unsorted should always
    # be there.
    maildircheck "$MAILDIRS/unsorted"
    [[ $? = 0 ]] || {
        error "Invalid fallback maildir destination, operation aborted."
        func "Returning error to caller."
        return 1
    }
    
    # loads up the filter cache (zsh compiled arrays)
    [[ -r "$MAILDIRS/cache/filters" ]] && {
        source $MAILDIRS/cache/filters
        ownfilters=1
    }

    # default maildir to filter is incoming
    mdinput=${1:-incoming}

    maildircheck "$MAILDIRS/$mdinput"
    [[ $? = 0 ]] || {
        error "Invalid maildir to filter: $mdinput"
        return 1
    }

    mails=`${=find} "$MAILDIRS/$mdinput" -maxdepth 2 -type f`
    numm=`print $mails | wc -l`

    [[ $numm = 0 ]] && {
        error "Nothing to filter inside maildir $mdinput"
        return 1
    }
    
    notice "Filtering maildir: $mdinput ($numm mails}"
    c=0

    for m in ${(f)mails}; do

        # clean interrupt
        [[ $global_quit = 1 ]] && {
            error "User break requested, interrupting operation"
            break
        }
        
        match=0
        c=$(($c + 1))

        # check if its an empty file
        _fsize=`zstat +size "$m"`
        [[ $_fsize = 0 ]] && {
            act "$c\t/ $numm\t(empty)"
            rm "$m"
            continue
        }

        # parse if its a mailinglist
        _ml=0
        hdr "$m" | ismailinglist
        [[ $? = 0 ]] && _ml=1

        list="blacklist"
        hdr "$m" | sender_isknown
        [[ $? = 0 ]] && {
            [[ "$mdinput" = "zz.blacklist" ]] && {
                act "$c\t/ $numm"
                continue
            }

            act "$c\t/ $numm\t-> zz.blacklist"

            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver zz.blacklist
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }
        
        hdr "$m" | awk '/Sender.*mailman-bounce/ { exit 1 }'
        [[ $? = 0 ]] || {
            [[ "$mdinput" = "zz.bounces" ]] && {
                act "$c\t/ $numm"
                continue
            }
            act "$c\t/ $numm\t-> zz.bounces"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver zz.bounces
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }
        
        [[ "$ownfilters" = "1" ]] && {

            func "processing through own filters"

            # run all filter regexps on the from: field
            _dest=""
            e_addr=()
            hdr "$m" | e_parse From
            [[ $? = 0 ]] && {
                femail="${(k)e_addr}" # e_parse From hit is always one
                for exp in ${(k)filter_from}; do
                    
                    # fuzzy match on a string (PCRE)
                    if [[ "$femail" =~ "$exp" ]]; then

                        # retrieve the filter destination maildir
                        _dest="${filter_from[$exp]}"

                        # if destination maildir is same as input, skip
                        [[ "$_dest" = "$mdinput" ]] && {
                            act "$c\t/ $numm"
                            match=1
                            break 
                        }
                        
                        act "$c\t/ $numm\t-> $_dest\t(from $femail)"

                        # tag mailinglists
                        [[ $DRYRUN = 1 ]] || {
                            if [[ $_ml = 1 ]]; then
                                printfile "$m" | deliver "$_dest" "+filtered +mailinglist"
                            else
                                printfile "$m" | deliver "$_dest" "+filtered"
                            fi
                        }

                        if [[ $? = 0 ]]; then
                            match=1
                            rm "$m"
                            break
                        else
                            error "Error filtering to maildir $_dest"
                            error "File: $m"
                            continue
                        fi
                    fi
                done
                [[ "$match" = "1" ]] && {
                    func "matched filter from: field"
                    continue
                }
            }

            _dest=""
            # recompile the array of destination addresses
            e_addr=()
            hdr "$m" | e_parse To
            hdr "$m" | e_parse Cc
            # run all filter regexps on the to: and cc: fields
            [[ $? = 0 ]] && {
                for ft in ${(k)e_addr}; do
                    for exp in ${(k)filter_to}; do
                        
                        # fuzzy match on a string (PCRE)
                        if [[ "$ft" =~ "$exp" ]]; then
                            
                            # retrieve the filter destination maildir
                            _dest="${filter_to[$exp]}"
                            
                            # if destination maildir is same as input, skip
                            [[ "$_dest" = "$mdinput" ]] && {
                                act "$c\t/ $numm"
                                match=1
                                break
                            }

                            act "$c\t/ $numm\t-> $_dest\t(to $ft)"
                            # tag mailinglists
                            [[ $DRYRUN = 1 ]] || {
                                if [[ $_ml = 1 ]]; then
                                    printfile "$m" | deliver "$_dest" "+filtered +mailinglist"
                                else
                                    printfile "$m" | deliver "$_dest" "+filtered"
                                fi
                            }
                            
                            if [[ $? = 0 ]]; then
                                match=1
                                rm "$m"
                                break
                            else
                                error "Error filtering to maildir $_dest"
                                error "File: $m"
                                continue
                            fi
                        fi
                    done
                    [[ "$match" = "1" ]] && { break }
                done
            }

            [[ "$match" = "1" ]] && {
                func "matched filter to:/cc: fields"
                continue
            }

        } # own filters

        list="whitelist"
        hdr "$m" | sender_isknown
        [[ $? = 0 ]] && {
            [[ "$mdinput" = "known" ]] && {
                act "$c\t/ $numm"
                continue
            }
            act "$c\t/ $numm\t-> known"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver known "+inbox +priv"
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }

        hdr "$m" | awk '/X-Spam-Flag.*YES/ { exit 1 }'
        { test $? = 0 } || {
            [[ "$mdinput" = "zz.spam" ]] && {
                act "$c\t/ $numm"
                continue
            }
            act "$c\t/ $numm\t-> zz.spam"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver zz.spam
                [[ $? = 0 ]] && { rm "$m" }
                continue
            }
        }

        # parse own email and aliases
        match=0
        for f in ${(k)e_addr}; do
            # check if destination address is in filter_own array
            [[ ${filter_own[(r)$f]} == ${f} ]] && {
                [[ "$mdinput" = "priv" ]] && {
                    act "$c\t/ $numm"
                    match=1
                    break
                }
                act "$c\t/ $numm\t-> priv"
                [[ $DRYRUN = 1 ]] || {
                    printfile "$m" | deliver priv "+priv"
                    [[ $? = 0 ]] && {
                        rm "$m";
                        match=1
                        break
                    }
                }
            }
        done
        [[ $match = 1 ]] && continue

        # its an unkown mailinglist
        [[ $_ml = 1 ]] && {
            [[ "$mdinput" = "unsorted.ml" ]] && {
                act "$c\t/ $numm"
                continue
            }
            act "$c\t/ $numm\t-> unsorted.ml"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver unsorted.ml "+unsorted +mailinglist"
                [[ $? = 0 ]] && { 
                    rm "$m"
                    continue
                }
            }
        }
        
        # if here then file to unsorted
        if [ "$mdinput" = "unsorted" ]; then
            act "$c\t/ $numm"
        else
            act "$c\t/ $numm\t-> unsorted"
            [[ $DRYRUN = 1 ]] || {
                printfile "$m" | deliver unsorted "+unsorted"
                [[ $? = 0 ]] && { rm "$m" }
            }
        fi

    done

    return 0
}

######
# MUTT

update_mutt() {
    act "updating mutt settings"
    func "MUTTDIR:     $MUTTDIR"

    ${=mkdir} "$MUTTDIR"
    ${=mkdir} "$MUTTDIR"/cache
    rm -f "$MUTTDIR"/rc

    gpgkey=""
    # detect the default gpg key to always encrypt also to self
    [[ -r $HOME/.gnupg/gpg.conf ]] && {
        gpgkey=`awk '/^default-key/ { print $2 }' $HOME/.gnupg/gpg.conf`
        act "default GPG key configured: $gpgkey"
    }
    cat<<EOF > "$MUTTDIR"/rc
#### Mutt config automatically generated by Jaro Mail
### do not edit: this file is overwritten by jaro update
### put your customizations in \$MAILDIRS/Identity.txt 

unset use_domain
set folder = '$MAILDIRS'
set spoolfile = '$MAILDIRS/known/'
set record = '$MAILDIRS/sent/'
set postponed= '$MAILDIRS/postponed/'
set tmpdir = '$MUTTDIR/cache'
set sendmail = "$WORKDIR/bin/jaro -q queue"
set header_cache= '$MUTTDIR/cache'
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro -q edit"
set mailcap_path = "$MUTTDIR/mailcap:$MAILDIRS/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q complete '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn sender<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn all<enter>" "add all addresses in whitelist"
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn sender<enter>" "add sender to blacklist"

# mailboxes in order of priority
source '$MUTTDIR/mboxes'

# specific configuration files
source '$WORKDIR/.mutt/gpg'
source '$WORKDIR/.mutt/crypto'
source '$WORKDIR/.mutt/general'
source '$WORKDIR/.mutt/formats'
source '$WORKDIR/.mutt/keybindings'
source '$WORKDIR/.mutt/colors'
source '$MAILDIRS/Identity.txt'
source '$MUTTDIR/muttpass'
EOF


    [[ "$gpgkey" = "" ]] || {
        # gpg special settings
        
        sysread -o 1 <<EOF >> "$MUTTDIR"/rc
## GnuPG specific settings
# create a pgp/mime encrypted attachment
set pgp_encrypt_only_command="gpgewrap gpg --batch --quiet --no-verbose --output - --encrypt --textmode --armor --always-trust --encrypt-to $gpgkey -- -r %r -- '%f'"

# create a pgp/mime encrypted and signed attachment
set pgp_encrypt_sign_command="gpgewrap gpg %?p?--passphrase-fd 0? --batch --quiet --no-verbose --textmode --output - --encrypt --sign %?a?-u %a? --armor --always-trust --encrypt-to $gpgkey -- -r %r -- '%f'"

## end of Jaro Mail generated muttrc
####################################
EOF
    }
    
    # MUTT MAILCAP
    sysread -o 1 <<EOF > $MUTTDIR/mailcap
text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    wwwtext=w3m
    if command -v elinks > /dev/null; then
    cat <<EOF >> $MUTTDIR/mailcap
text/html; elinks -dump -dump-charset %{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v w3m > /dev/null; then
    cat <<EOF >> $MUTTDIR/mailcap
text/html; w3m -I %{charset} -T text/html %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v lynx > /dev/null; then
    cat <<EOF >> $MUTTDIR/mailcap
text/html; lynx -dump -assume_charset=%{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    fi

    { test -r "${MAILDIRS}/Applications.txt" } && {

    # here is the tweak to open attachments
    # with Mutt without blocking it (fork)

    apptypes=`cat "${MAILDIRS}/Applications.txt"`
    for t in ${(f)apptypes}; do
    eval `print $t | awk '
    { print "_type=" $1 "; _app=" $2 ";" }'`
    cat <<EOF >> $MUTTDIR/mailcap
${_type}; a="${MAILDIRS}/tmp" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && ${_app} "\$a"/"\$f"
EOF
    done
    cat <<EOF >> $MUTTDIR/mailcap
application/*; a="${MAILDIRS}/tmp" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && jaro preview "\$a"/"\$f"
EOF
    } # Applications.txt

    # this one is empty and sources files in temp when necessary
    rm -f "$MUTTDIR/muttpass"
    touch "$MUTTDIR/muttpass"

    # just the header, will be completed later
    rm -f $MUTTDIR/mboxes
    print -n "mailboxes +known +priv" > $MUTTDIR/mboxes

    for f in `cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $4 }'`; do
        # MUTT (generate mailboxes priority this parser)
        print  " \\" >> $MUTTDIR/mboxes
        print -n " +${f} " >> $MUTTDIR/mboxes
    done
    print " \\" >> $MUTTDIR/mboxes
    print " +unsorted.ml +unsorted" >> $MUTTDIR/mboxes
    
    ztmp
    ttmp=$ztmpfile
    uniq $MUTTDIR/mboxes > $ttmp
    mv $ttmp $MUTTDIR/mboxes

}

    
# sieve_filter() gets an array of patterns to match and builds a long rule
# for which if they match the conditional directive they all go in one folder
# $1 = conditional directive
# $2 = folder to fileinto
# sieve_filter_array: array of entries
typeset -alU sieve_filter_array
sieve_filter() {
    condition="$1"
    fileinto="$2"

    cat <<EOF >> "$MAILDIRS/Filters.sieve"

# $fileinto
$condition [
EOF
    c=${#sieve_filter_array}
    for i in $sieve_filter_array; do
    print -n "\"$i\"" >> "$MAILDIRS/Filters.sieve"
    c=$(( $c - 1 ))
    { test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
    print >> "$MAILDIRS/Filters.sieve"
    done

    cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto :create "$fileinto"; stop; }

EOF
    return 0
}

typeset -A sieve_filter_map
# sieve_complex_filter gets a map of patterns as an argument and builds a
# long rule for which any key matching it gets delivered to its value folder
# $1 = conditional directive
# sieve_filter_map = map of patterns, key is match and value is destination
# assign with set -A sieve_filter_map yourmap
sieve_complex_filter() {
    [[ ${#sieve_filter_map} == 0 ]] && { return 1 }
    condition="$1"
    func "Sieve complex filter entries: ${#sieve_filter_map}"

    for fil in ${(k)sieve_filter_map}; do
        print "$condition \"${fil}\" { fileinto :create \"${sieve_filter_map[$fil]}\"; stop; }" \
            >> "$MAILDIRS/Filters.sieve"
    done

    return 0
}

update_sieve() {

    #######
    # SIEVE
    act "generating sieve filter rules"
    id=`datestamp`.$RANDOM
    newlock "$MAILDIRS/Filters.sieve"
    rm -f "$MAILDIRS/Filters.sieve"
    touch "$MAILDIRS/Filters.sieve"
    chmod 600 "$MAILDIRS/Filters.sieve"
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# mailbox supports fileinto :create
require ["fileinto","mailbox","variables"];

EOF

    # blacklist
    [[ -r "$MAILDIRS"/blacklist.abook ]] && {
        sieve_filter_array=()
        
        for i in `awk -F'=' '
/^email/ { print $2 }
' "$MAILDIRS"/blacklist.abook`; do
            sieve_filter_array+=("$i")
        done
        
        { test "${#sieve_filter_array}" = "0" } || {
            sieve_filter \
                'if header :contains "From"' \
                zz.blacklist
        }
    }
    
    # bounces
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# bounces
if header :contains "Sender" "mailman-bounce" {
    fileinto :create "zz.bounces";
    stop;
}

#############
# own filters

EOF

    set -A sieve_filter_map ${(kv)filter_to}
    sieve_complex_filter 'if header :contains [ "To","Cc" ] '

    set -A sieve_filter_map ${(kv)filter_from}
    sieve_complex_filter 'if header :contains "From"'




    ##############################################################
    # if the sender is known (whitelist) then put mail in
    # high priority 'known' maildir or INBOX (sieve)

    act "compiling whitelist rules from addressbook"
    func "generating whitelist for sieve filters"

    [[ -r "$MAILDIRS"/whitelist.abook ]] && {
        sieve_filter_array=()
        for i in `awk -F'=' '
/^email/ { print $2 }
' "$MAILDIRS"/whitelist.abook`; do
            sieve_filter_array+=("$i")
        done
        sieve_filter \
            'if header :contains "From"' \
            INBOX
    }
        
        cat <<EOF >> "$MAILDIRS/Filters.sieve"
# spam
if header :is "X-Spam-Flag" "YES" {
    fileinto :create "zz.spam"; stop;
}

EOF

    # own addresses and aliases
    sieve_filter_array=($filter_own)
    sieve_filter \
    'if header :contains [ "To","Cc" ] ' \
    priv

    # unsorted
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
if header :matches "List-Id" "*<*>" {
  fileinto :create "lists.\${2}"; stop; }
elsif header :matches "X-BeenThere" "*@*" {
 fileinto :create "lists.\${1}.\${2}"; stop; }
elsif header :matches "List-Post" "<mailto:*@*" {
 fileinto :create "lists.\${1}.\${2}"; stop; }

if anyof (header :contains "X-Mailman-Version" ".",
          header :contains "Mailing-List" ".") {
  fileinto :create "lists.unsorted"; stop; }

fileinto :create "unsorted";
EOF

    unlock "$MAILDIRS/Filters.sieve"

    return 0
} # end of update()
