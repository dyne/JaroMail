#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2014 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

###################
# Filters workflow:
#
#  1. Check if From in blacklist   -> zz.blacklist
#  2. Check if /Sender.*bounce/    -> zz.bounces
#  3. Check if From Filters match  -> own.setup
#  4. Check if To   Filters match  -> own.setup
#  5. Check if From in whitelist   -> known
#  6. Check if /X-Spam-Flag.*YES/  -> zz.spam
#  7. Check if To own address      -> priv
#  8. All the rest                 -> unsorted
#

# load zsh filter cache arrays
{ test -r  "$MAILDIRS/cache/filters" } && {
    source "$MAILDIRS/cache/filters" }

init_inbox() {
    # make sure maildirs where to put mails exist
    ${=mkdir} "$MAILDIRS"
    maildirmake "$MAILDIRS/incoming"
    maildirmake "$MAILDIRS/known"
    maildirmake "$MAILDIRS/sent"
    maildirmake "$MAILDIRS/priv"
    maildirmake "$MAILDIRS/postponed"
    maildirmake "$MAILDIRS/unsorted"
    maildirmake "$MAILDIRS/unsorted.ml"
    maildirmake "$MAILDIRS/remember"
    maildirmake "$MAILDIRS/outbox"

    ${=mkdir} "$MAILDIRS/cache"
    ${=mkdir} "$MAILDIRS/logs"
    ${=mkdir} "$MAILDIRS/tmp"

    { test -d "$MAILDIRS/Accounts" } || {
	${=mkdir} "$MAILDIRS/Accounts"
	cp "$WORKDIR"/Accounts/* "$MAILDIRS/Accounts/" }

    { test -r "$MAILDIRS"/Manual.pdf } || {
	cp "$WORKDIR"/jaromail-manual.pdf "$MAILDIRS"/Manual.pdf }

    { test -r "$MAILDIRS"/Identity.txt } || {
	cp "$WORKDIR"/Identity.txt "$MAILDIRS"/Identity.txt }

    { test -r "$MAILDIRS"/Filters.txt } || {
	cp "$WORKDIR"/Filters.txt "$MAILDIRS"/Filters.txt }

    { test -r "$MAILDIRS"/Aliases.txt } || {
	cp "$WORKDIR"/Aliases.txt "$MAILDIRS"/Aliases.txt }

    { test -r "$MAILDIRS"/Applications.txt } || {
	cp "$WORKDIR"/Applications.txt "$MAILDIRS"/Applications.txt }

    return 0
}

# reads all configurations and creates a cache of what is read
# the cache consists of array and maps declarations for zsh
update_filters() {
    { test -r "$MAILDIRS/Filters.txt" } || {
	error "Filters not found in $MAILDIRS/Filters.txt"
	return 1 }

    notice "Updating filters..."

    ff="$MAILDIRS/cache/filters"
    ${=mkdir} "$MAILDIRS/cache"

    { test -r "$ff" } && { rm -f "$ff" }
    newlock "$ff"
    cat <<EOF >> "$ff"
# automatically generated by jaromail
typeset -Al  filter_from
typeset -alU filter_own
typeset -Al  filter_to
filter_from=()
filter_own=()
filter_to=()

EOF
    ffilters=`cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`

    # insert filter rules in the cache
    for f in ${(f)ffilters}; do
	header="${f[(ws:;:)1]}"
	regexp="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		cat <<EOF >> "$ff"
filter_to+=("${regexp}" "${destination}")
EOF
		func "from: <${regexp}> -> ${destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    from)
		cat <<EOF >> "$ff"
filter_from+=("${regexp}" "${destination}")
EOF
		func "to: <${regexp}> -> ${destination}"
		maildirmake $MAILDIRS/$destination
		;;

	    *)
		error "invalid filter: $f"
		;;
	esac
    done

    # compile the list of own addresses and aliases
    for i in `awk '
/^#/ { next }
/^$/ { next }
/^email/ { print $2 }' \
 "$MAILDIRS"/Accounts/*`; do
	cat <<EOF >> "$ff"
filter_own+=($i)
EOF
    done
    { test -r $MAILDIRS/Aliases.txt } && {
	for i in `awk '
/^#/ { next }
/^$/ { next }
{ print $1 }' "$MAILDIRS/Aliases.txt"`; do
	    cat <<EOF >> "$ff"
filter_own+=($i)
EOF
	done
    }

    unlock "$ff"
    zcompile "$ff"
    # recursive reload
    source "$WORKDIR/zlibs/filters"
    return 0
}


filter_maildir() {
    typeset -h mdinput
    mdinput="$1"

    # for safety we bail out in case the final fallback
    # maildir is not existing. unsorted should always
    # be there.
    maildircheck "$MAILDIRS/unsorted"
    { test $? = 0 } || {
	error "Invalid fallback maildir destination, operation aborted."
	func "Returning error to caller."
	return 1; }

    # loads up the filter cache (zsh compiled arrays)
    { test -r "$MAILDIRS/cache/filters" } && {
	source $MAILDIRS/cache/filters
	ownfilters=1 }

    { test "$1" = "" } && { mdinput=incoming }

    maildircheck "$MAILDIRS/$mdinput"
    { test $? = 0 } || {
	error "Invalid maildir to filter: $mdinput"
	return 1; }

    numm=`${=find} "$MAILDIRS/$mdinput" -maxdepth 2 -type f|wc -l`
    mails=`${=find} "$MAILDIRS/$mdinput" -maxdepth 2 -type f`

    { test "$numm" = "0" } && {
	error "Nothing to filter inside maildir $mdinput"
	return 1 }

    notice "Filtering maildir: $mdinput ($numm mails}"
    c=0

    for m in ${(f)mails}; do
	match=0
	c=$(($c + 1))

	list="blacklist"
	hdr "$m" | sender_isknown
	{ test $? = 0 } && {
	    cat "$m" | deliver zz.blacklist
	    { test $? = 0 } && { rm "$m" }
	    act "$c\t\t/ $numm\t\t->\tzz.blacklist"
	    continue }

	hdr "$m" | awk '/Sender.*mailman-bounce/ { exit 1 }'
	{ test $? = 0 } || {
	    act "$c\t\t/ $numm\t\t->\tzz.bounces"
	    cat "$m" | deliver zz.bounces
	    { test $? = 0 } && { rm "$m" }
	    continue }

	{ test "$ownfilters" = "1" } && {

	    func "processing through own filters"
	    ffrom=`hdr "$m" | ${WORKDIR}/bin/fetchaddr -x From -a`

	    # run all filter regexps on the from: field
	    { test "$ffrom" = "" } || {
		femail="${ffrom[(ws:,:)1]}"
		for exp in ${(k)filter_from}; do
		    # special zsh parsing in PCRE (=~)
		    if [[ "$femail" =~ "$exp" ]]; then
			# if destination maildir is same as input, skip
			{ test "${filter_from[$exp]}" = "$mdinput" } && {
			    act "$c\t\t/ $numm"
			    match=1; break }
			act "$c\t\t/ $numm\t\t-> ${filter_from[$exp]}"
			cat "$m" | deliver ${filter_from[$exp]}
			if [ $? = 0 ]; then
			    func "from filter match: $exp"
			    match=1; rm "$m"; break
			else
			    error "Error filtering to maildir ${filter_from[$exp]}"
			    error "File: $m"
			    continue
			fi
		    fi
		done
	    }
	    { test "$match" = "1" } && { continue }

	    typeset -alU ftos
	    # recompile the array of destination addresses
	    ftos=(`hdr "$m" | ${WORKDIR}/bin/fetchaddr -x cc -a | cut -d, -f1`)
	    ftos+=(`hdr "$m" | ${WORKDIR}/bin/fetchaddr -x to -a | cut -d, -f1`)

	    # run all filter regexps on the to: and cc: fields
	    { test "$ftos" = "" } || {
		for ft in ${(f)ftos}; do
		    for exp in ${(k)filter_to}; do
			# special zsh parsing in PCRE (=~)
			if [[ "$ft" =~ "$exp" ]]; then
			    # if destination maildir is same as input, skip
			    { test "${filter_to[$exp]}" = "$mdinput" } && {
				act "$c\t\t/ $numm"
				match=1; break }
			    act "$c\t\t/ $numm\t\t-> ${filter_to[$exp]}"
			    cat "$m" | deliver ${filter_to[$exp]}
			    if [ $? = 0 ]; then
				func "to filter match: $exp"
				match=1; rm "$m"; break
			    else
				error "Error filtering to maildir ${filter_to[$exp]}"
				error "File: $m"
				continue
			    fi
			fi
		    done
		    { test "$match" = "1" } && { break }
		done
	    }

	    { test "$match" = "1" } && { func "own filter match"; continue }

	} # own filters

	list="whitelist"
	hdr "$m" | sender_isknown
	{ test $? = 0 } && {
	    act "$c\t\t/ $numm\t\t-> known"
	    cat "$m" | deliver known
	    { test $? = 0 } && { rm "$m" }
	    continue }

	hdr "$m" | awk '/X-Spam-Flag.*YES/ { exit 1 }'
	{ test $? = 0 } || {
	    act "$c\t\t/ $numm\t\t-> zz.spam"
	    cat "$m" | deliver zz.spam
	    { test $? = 0 } && { rm "$m" }
	    continue }

	# parse own email and aliases
	match=0
	for f in $ftos; do
	    # check if destination address is in filter_own array
	    if [[ ${filter_own[(r)$f]} == ${f} ]] ; then
		act "$c\t\t/ $numm\t\t-> priv"
		cat "$m" | deliver priv
		{ test $? = 0 } && { rm "$m"; match=1; break }
	    fi
	done
	{ test "$match" = "1" } && { continue }

	# if here then file to unsorted
	if [ "$mdinput" = "unsorted" ]; then
	    act "$c\t\t/ $numm"
	else
	    act "$c\t\t/ $numm\t\t-> unsorted"
	    cat "$m" | deliver unsorted
	    { test $? = 0 } && { rm "$m" }
	fi

    done

    return 0
}

######
# MUTT

update_mutt() {
    act "updating mutt settings"
    func "MUTTDIR:     $MUTTDIR"

    func "binary: $mutt"
    func "pgpewrap: $pgpewrap"
    func "lock: $dotlock"
    ${=mkdir} $MUTTDIR
    ${=mkdir} $MUTTDIR/cache
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = '$MAILDIRS'
set spoolfile = '$MAILDIRS/known/'
set record = '$MAILDIRS/sent/'
set postponed= '$MAILDIRS/postponed/'
set tmpdir = '$MUTTDIR/cache'
set sendmail = "$WORKDIR/bin/jaro -q queue"
set header_cache= '$MUTTDIR/cache'
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro -q edit"
set mailcap_path = "$MUTTDIR/mailcap:$MAILDIRS/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q complete '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn sender<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn all<enter>" "add all addresses in whitelist"
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn sender<enter>" "add sender to blacklist"

# mailboxes in order of priority
source '$MUTTDIR/mboxes'

# specific configuration files
source '$WORKDIR/.mutt/gpg'
source '$WORKDIR/.mutt/crypto'
source '$WORKDIR/.mutt/general'
source '$WORKDIR/.mutt/formats'
source '$WORKDIR/.mutt/keybindings'
source '$WORKDIR/.mutt/colors'
source '$MAILDIRS/Identity.txt
source '$TMPDIR/muttpass'
EOF


#####################
# helper applications
act "configuring helper applications"
cat <<EOF >> "$MUTTDIR/rc"
## end of Jaro Mail generated muttrc
####################################

EOF

    # MUTT MAILCAP
    cat <<EOF > $MUTTDIR/mailcap
text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    wwwtext=w3m
    if command -v elinks > /dev/null; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; elinks -dump -dump-charset %{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v w3m > /dev/null; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; w3m -I %{charset} -T text/html %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v lynx > /dev/null; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; lynx -dump -assume_charset=%{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    fi

    { test -r "${MAILDIRS}/Applications.txt" } && {

	# here is the tweak to open attachments
	# with Mutt without blocking it (fork)

    apptypes=`cat "${MAILDIRS}/Applications.txt"`
    for t in ${(f)apptypes}; do
	eval `print $t | awk '
    { print "_type=" $1 "; _app=" $2 ";" }'`
	cat <<EOF >> $MUTTDIR/mailcap
${_type}; a="${TMPDIR}" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && ${_app} "\$a"/"\$f"
EOF
    done
    cat <<EOF >> $MUTTDIR/mailcap
application/*; a="${TMPDIR}" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && jaro preview "\$a"/"\$f"
EOF
    } # Applications.txt

    # this one is empty and sources files in temp when necessary
    touch $TMPDIR/muttpass

    # just the header, will be completed later
    rm -f $MUTTDIR/mboxes
    print -n "mailboxes +known +priv" > $MUTTDIR/mboxes

    for f in `cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $4 }'`; do
	# MUTT (generate mailboxes priority this parser)
	print  " \\" >> $MUTTDIR/mboxes
	print -n " +${f} " >> $MUTTDIR/mboxes
    done
    print " \\" >> $MUTTDIR/mboxes
    print " +unsorted.ml +unsorted" >> $MUTTDIR/mboxes

    uniq $MUTTDIR/mboxes > $TMPDIR/mboxes
    mv $TMPDIR/mboxes $MUTTDIR/mboxes

}

# $1 = conditional directive
# $2 = folder to fileinto
# sieve_filter_array: array of entries
typeset -alU sieve_filter_array
sieve_filter() {
    condition="$1"
    fileinto="$2"

    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# $fileinto
$condition [
EOF
    c=${#sieve_filter_array}
    for i in $sieve_filter_array; do
	print -n "\"$i\"" >> "$MAILDIRS/Filters.sieve"
	c=$(( $c - 1 ))
	{ test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
	print >> "$MAILDIRS/Filters.sieve"
    done

    cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto "$fileinto"; stop; }

EOF
    return 0
}

update_sieve() {

    #######
    # SIEVE
    act "generating sieve filter rules"
    id=$datestamp.$RANDOM
    newlock "$MAILDIRS/Filters.sieve"
    rm -f "$MAILDIRS/Filters.sieve"
    touch "$MAILDIRS/Filters.sieve"
    chmod 600 "$MAILDIRS/Filters.sieve"
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
require "fileinto";

EOF

    # blacklist
    sieve_filter_array=()
    newlock "$TMPDIR/blacklist.sieve.$id"
    cat <<EOF | ${SQL} -batch ${addressbook} \
	>> "$TMPDIR/blacklist.sieve.$id"
SELECT email FROM blacklist;
EOF
    for i in `cat "$TMPDIR/blacklist.sieve.$id"`; do
	sieve_filter_array+=("$i"); done
    unlink "$TMPDIR/blacklist.sieve.$id"

    sieve_filter \
	'if header :contains "From"' \
	zz.blacklist

    # bounces
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# bounces
if header :contains "Sender" "mailman-bounce" {
    fileinto "zz.bounces";
    stop;
}

#############
# own filters

EOF

    # now do our own filters
    sieve_filter_array=()
    { test ${#filter_to} -gt 0 } && {

	for f in ${(k)filter_to}; do
	    sieve_filter_array+=($f); done

	sieve_filter \
	    'if header :contains "To"' \
	    filters
    }

    sieve_filter_array=()
    { test ${#filter_from} -gt 0 } && {

	for f in ${(k)filter_from}; do
	    sieve_filter_array+=($f); done

	sieve_filter \
	    'if header :contains "From"' \
	    filters
    }

    ##############################################################
    # if the sender is known (whitelist) then put mail in
    # high priority 'known' maildir or INBOX (sieve)

    act "compiling whitelist rules from addressbook"
    func "generating whitelist for sieve filters"

    sieve_filter_array=()
    newlock "$TMPDIR/whitelist.sieve.$id"
    cat <<EOF | ${SQL} -batch ${addressbook} \
	>> "$TMPDIR/whitelist.sieve.$id"
SELECT email FROM whitelist;

EOF

    for i in `cat "$TMPDIR/whitelist.sieve.$id"`; do
	sieve_filter_array+=("$i"); done

    unlink "$TMPDIR/whitelist.sieve.$id"

    sieve_filter \
	'if header :contains "From"' \
	INBOX

    cat <<EOF >> "$MAILDIRS/Filters.sieve"
# spam
if header :is "X-Spam-Flag" "YES" {
    fileinto "zz.spam"; stop;
}

EOF

    # own addresses and aliases
    sieve_filter_array=($filter_own)
    sieve_filter \
	'if header :contains [ "To","Cc" ] ' \
	priv

    # unsorted
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
fileinto "unsorted";
EOF

    unlock "$MAILDIRS/Filters.sieve"

    return 0
} # end of update()
